<?xml version="1.0"?>
<doc>
    <assembly>
        <name>GoRogue</name>
    </assembly>
    <members>
        <member name="T:GoRogue.AdjacencyRule">
            <summary>
            Class representing a method for determining which coordinates are adjacent to a given
            coordinate, and in which directions those neighbors are. Cannot be instantiated -- premade
            static instances are provided.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.CARDINALS">
            <summary>
            Represents method of determining adjacency where neighbors are considered adjacent if
            they are in a cardinal direction, eg. 4-way (manhattan-based) connectivity.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.DIAGONALS">
            <summary>
            Represents method of determining adjacency where neighbors are considered adjacent if
            they are in a diagonal direction.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.EIGHT_WAY">
            <summary>
            Represents method of determining adjacency where all 8 possible neighbors are considered
            adjacent (eg. 8-way connectivity).
            </summary>
        </member>
        <member name="T:GoRogue.AdjacencyRule.Types">
            <summary>
            Enum representing AdjacencyRule types. Useful for easy mapping of AdjacencyRule types to
            a primitive type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Types.CARDINALS">
            <summary>
            Type for AdjacencyRule.CARDINALS.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Types.DIAGONALS">
            <summary>
            Type for AdjacencyRule.DIAGONALS.
            </summary>
        </member>
        <member name="F:GoRogue.AdjacencyRule.Types.EIGHT_WAY">
            <summary>
            Type for AdjacencyRule.EIGHT_WAY.
            </summary>
        </member>
        <member name="P:GoRogue.AdjacencyRule.Type">
            <summary>
            Enum value representing the method of determining adjacency -- useful for using
            AdjacencyRule types in switch statements.
            </summary>
        </member>
        <member name="M:GoRogue.AdjacencyRule.ToAdjacencyRule(GoRogue.AdjacencyRule.Types)">
            <summary>
            Gets the AdjacencyRule class instance representing the adjacency type specified.
            </summary>
            <param name="adjacencyRuleType">The enum value for the adjacency method.</param>
            <returns>The AdjacencyRule class representing the given adjacency method type.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.DirectionsOfNeighbors">
            <summary>
            Gets directions leading to neighboring locations, according to the current adjacency
            method. Cardinals are returned before any diagonals.
            </summary>
            <returns>Directions that lead to neighboring locations.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.DirectionsOfNeighborsClockwise(GoRogue.Direction)">
            <summary>
            Gets directions leading to neighboring locations, according to the current adjacency
            method. Appropriate directions are returned in clockwise order from the given direction.
            Null or Direction.NONE causes the default to be used (UP for CARDINALS or EIGHT_WAY, and
            UP_RIGHT for DIAGONALS).
            </summary>
            <param name="startingDirection">The direction to start with.</param>
            <returns>Directions that lead to neighboring locations.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.DirectionsOfNeighborsCounterClockwise(GoRogue.Direction)">
            <summary>
            Gets directions leading to neighboring locations, according to the current adjacency
            method. Appropriate directions are returned in counter-clockwise order from the given
            direction. Null or Direction.NONE causes the default to be used (UP for CARDINALS or
            EIGHT_WAY, and UP_RIGHT for DIAGONALS).
            </summary>
            <param name="startingDirection">The direction to start with.</param>
            <returns>Directions that lead to neighboring locations.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.Neighbors(GoRogue.Coord)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Cardinals are returned before any diagonals.
            </summary>
            <param name="startingLocation">Location to return neighbors for.</param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.Neighbors(System.Int32,System.Int32)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Cardinals are returned before any diagonals.
            </summary>
            <param name="startingX">X-coordinate of location to return neighbors for.</param>
            <param name="startingY">Y-coordinate of location to return neighbors for.</param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsClockwise(GoRogue.Coord,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in clockwise order from the given direction. Null or
            Direction.NONE causes the default to be used (UP for CARDINALS or EIGHT_WAY, and UP_RIGHT
            for DIAGONALS).
            </summary>
            <param name="startingLocation">Location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding clockwise.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsClockwise(System.Int32,System.Int32,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in clockwise order from the given direction. Null or
            Direction.NONE causes the default to be used (UP for CARDINALS or EIGHT_WAY, and UP_RIGHT
            for DIAGONALS).
            </summary>
            <param name="startingX">X-coordinate of location to return neighbors for.</param>
            <param name="startingY">Y-coordinate of location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding clockwise.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsCounterClockwise(GoRogue.Coord,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in counter-clockwise order from the given direction. Null or
            Direction.NONE causes the default to be used (UP for CARDINALS or EIGHT_WAY, and UP_LEFT
            for DIAGONALS).
            </summary>
            <param name="startingLocation">Location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding counter-clockwise.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.NeighborsCounterClockwise(System.Int32,System.Int32,GoRogue.Direction)">
            <summary>
            Gets all neighbors of the specified location, based on the current adjacency method.
            Neighbors are returned in counter-clockwise order from the given direction. Null or
            Direction.NONE causes the default to be used (UP for CARDINALS or EIGHT_WAY, and UP_LEFT
            for DIAGONALS).
            </summary>
            <param name="startingX">X-coordinate of location to return neighbors for.</param>
            <param name="startingY">Y-coordinate of location to return neighbors for.</param>
            <param name="startingDirection">
            The neighbor in this direction will be returned first, proceeding counter-clockwise.
            </param>
            <returns>All neighbors of the given location.</returns>
        </member>
        <member name="M:GoRogue.AdjacencyRule.ToString">
            <summary>
            Returns a string representation of the AdjacencyRule.
            </summary>
            <returns>A string representation of the AdjacencyRule.</returns>
        </member>
        <member name="T:GoRogue.BoundedRectangle">
            <summary>
            A class that contains a rectangle Area that is automatically "locked" to being inside the
            BoundingBox. A typical use might be keeping track of a camera view area.
            </summary>
        </member>
        <member name="M:GoRogue.BoundedRectangle.#ctor(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Constructor. Takes the initial area and bounding box.
            </summary>
            <param name="area">Initial value for Area.</param>
            <param name="boundingBox">Initial bounding box for Area.</param>
        </member>
        <member name="P:GoRogue.BoundedRectangle.Area">
            <summary>
            The rectangle that is guaranteed to be contained within the BoundingBox. Although it does
            not specifically provide a set accessor, this property is returning a reference and as
            such may be assigned to. Whenever the rectangle is retrieved, if it is not contained
            within BoundingBox it will be modified as necessary to keep it within those bounds.
            </summary>
        </member>
        <member name="P:GoRogue.BoundedRectangle.BoundingBox">
            <summary>
            The rectangle which Area is automatically bounded to. Similar to area, although this
            property does not explicitly provide a set accessor, it is returning a reference so the
            property may be assigned to.
            </summary>
        </member>
        <member name="T:GoRogue.Coord">
            <summary>
            2d coordinate class. You cannot create instances of this class using a constructor --
            instead, use the Get function to create instances. Also provides numerous static functions to
            deal with grid/Coord-related math, operations, etc.
            </summary>
            <remarks>
            If you want the coordinate (1, 2), use Coord.Get(1, 2), and it returns you a Coord instance.
            These instances are read-only, however operators such as addition, etc., are provided. This
            is due to optimizations under the hood. By default, the class keeps a static, internal array
            that contains an instance of every coordinate between (-3, -3), and (255, 255). If the
            coordinate x and y values given to Get are within this range, Get returns the appropriate
            instance from the array. If the coordinates given are outside of the range, it simply returns
            a new instance. Since most of the coordinates used in roguelike/grid based games will be
            between (-3, -3) and (255, 255), this can end up drastically reducing the number of memory
            allocations that need to be done since there will exist one and only one instance of the
            Coord class for each value in that range. Since allocations are expensive due to garbage
            collections, this can significantly improve on efficiency. Later, support may be added for
            modifying this range as necessary.
            </remarks>
        </member>
        <member name="F:GoRogue.Coord.X">
            <summary>
            X-value of the coordinate.
            </summary>
        </member>
        <member name="F:GoRogue.Coord.Y">
            <summary>
            Y-value of the coordinate.
            </summary>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Calculates degree bearing of the line (start =&gt; end), where 0 is in the direction Direction.UP.
            </summary>
            <param name="start">Coordinate of line starting point.</param>
            <param name="end">Coordinate of line ending point.</param>
            <returns>The degree bearing of the line specified by the two given points.</returns>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates degree bearing of the line ((startX, startY) =&gt; (endX, endY)), where 0 is
            in the direction Direction.UP.
            </summary>
            <param name="startX">X-value of the coordinate of line starting point.</param>
            <param name="startY">Y-value of the coordinate of line starting point.</param>
            <param name="endX">X-value of the coordinate of line ending point.</param>
            ///
            <param name="endY">Y-value of the coordinate of line ending point.</param>
            <returns>The degree bearing of the line specified by the two given points.</returns>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(GoRogue.Coord)">
            <summary>
            Calculates the degree bearing of a line with the given delta-x and delta-y values, where
            0 degreees is in the direction Direction.UP.
            </summary>
            <param name="deltaChange">
            Vector, where deltaChange.X is the change in x-values across the line, and deltaChange.Y
            is the change in y-values across the line.
            </param>
            <returns>The degree bearing of the line with the given dx and dy values.</returns>
        </member>
        <member name="M:GoRogue.Coord.BearingOfLine(System.Int32,System.Int32)">
            <summary>
            Calculates the degree bearing of a line with the given delta-x and delta-y values, where
            0 degreees is in the direction Direction.UP.
            </summary>
            <param name="dx">The change in x-values across the line.</param>
            <param name="dy">the change in y-values across the line</param>
            <returns>The degree bearing of the line with the given dx and dy values.</returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root -- eg.,
            (c2.X - c1.X) * (c2.X - c1.X) + (c2.Y - c1.Y) * (c2.Y - c1.Y). Use this if you only care
            about the magnitude of the distance -- eg., if you're trying to compare two distances.
            Omitting the square root provides a speed increase.
            </summary>
            <param name="c1">The first point.</param>
            <param name="c2">The second point.</param>
            <returns>
            The "magnitude" of the euclidean distance between the two points -- basically the
            distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root -- eg., (x2
            - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1). Use this if you only care about the magnitude
            of the distance -- eg., if you're trying to compare two distances. Omitting the square
            root provides a speed increase.
            </summary>
            <param name="x1">The x-value of the first location.</param>
            <param name="y1">The y-value of the first location.</param>
            <param name="x2">The x-value of the second location.</param>
            <param name="y2">The y-value of the second location.</param>
            <returns>
            The "magnitude" of the euclidean distance between the two points -- basically the
            distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(GoRogue.Coord)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root, given the
            dx and dy values between two points -- eg., deltaChange.X * deltaChange.X + deltaChange.Y
            * deltaChange.Y. Use this if you only care about the magnitude of the distance -- eg., if
            you're trying to compare two distances. Omitting the square root provides a speed increase.
            </summary>
            <param name="deltaChange">
            Vector, where deltaChange.X is the change in x-values between the two points, and
            deltaChange.Y is the change in y-values between the two points.
            </param>
            <returns>
            The "magnitude" of the euclidean distance of two locations with the given dx and dy
            values -- basically the distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.EuclideanDistanceMagnitude(System.Int32,System.Int32)">
            <summary>
            Returns the result of the euclidean distance formula, without the square root, given the
            dx and dy values between two points -- eg., deltaChange.X * deltaChange.X + deltaChange.Y
            * deltaChange.Y. Use this if you only care about the magnitude of the distance -- eg., if
            you're trying to compare two distances. Omitting the square root provides a speed increase.
            </summary>
            <param name="dx">The change in x-values between the two points.</param>
            <param name="dy">The change in y-values between the two points.</param>
            <returns>
            The "magnitude" of the euclidean distance of two locations with the given dx and dy
            values -- basically the distance formula without the square root.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.Get(System.Int32,System.Int32)">
            <summary>
            Returns the proper Coord instance for the given x and y values. Will return the one in
            the array if the values are in the appropriate range, otherwise will create a new one and
            return that one.
            </summary>
            <param name="x">The x-value for the coordinate.</param>
            <param name="y">The y-value for the coordinate.</param>
            <returns>The Coord representing the given x-value and y-value.</returns>
        </member>
        <member name="M:GoRogue.Coord.Midpoint(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the midpoint between the two points.
            </summary>
            <param name="c1">The first point.</param>
            <param name="c2">The second point.</param>
            <returns>The midpoint between c1 and c2.</returns>
        </member>
        <member name="M:GoRogue.Coord.Midpoint(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the midpoint between the two points.
            </summary>
            <param name="x1">The x-value of the first location.</param>
            <param name="y1">The y-value of the first location.</param>
            <param name="x2">The x-value of the second location.</param>
            <param name="y2">The y-value of the second location.</param>
            <returns>The midpoint between the two points.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            - operator. Returns the coordinate (c1.X - c2.X, c1.Y - c2.Y)
            </summary>
            <param name="c1">The first coordinate.</param>
            <param name="c2">The coordinate to subtract from c1.</param>
            <returns>c1 - c2, eg. (c1.X - c2.X, c1.Y - c2.Y)</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Subtraction(GoRogue.Coord,System.Int32)">
            <summary>
            - operator. Subtracts scalar i from the x and y values of c1, eg. returns (c.X - i, c.Y - i).
            </summary>
            <param name="c">Coordinate to subtract the scalar from.</param>
            <param name="i">Scalar to subtract from the coordinate.</param>
            <returns></returns>
        </member>
        <member name="M:GoRogue.Coord.op_Inequality(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            True if either the x-values or y-values are not equal.
            </summary>
            <param name="c1">First coordinate to compare.</param>
            <param name="c2">Second coordinate to compare.</param>
            <returns>
            True if either the x-values or y-values are not equal, false if they are both equal.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Multiply(GoRogue.Coord,System.Int32)">
            <summary>
            * operator. Multiplies the x-value and y-value of c by i, eg. returns (c.X * i, c.Y * i)
            </summary>
            <param name="c">Coordinate to multiply by the scalar.</param>
            <param name="i">Scalar to multiply the coordinate by.</param>
            <returns>Coordinate (c.X * i, c.Y * i)</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Multiply(GoRogue.Coord,System.Double)">
            <summary>
            * operator, similar to the int version. Rounds x-value and y-value to the nearest
            integer. Effectively "scale c by i".
            </summary>
            <param name="c">The coordinate to multiply by the scalar.</param>
            <param name="i">The scalar to multiply the coordinate by.</param>
            <returns>
            Coordinate (c.X * i, c.Y * i), with the resulting values rounded to nearest integer.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Division(GoRogue.Coord,System.Int32)">
            <summary>
            / operator. Divides the x-value and y-value of c by i, eg. returns (c.X / i, c.Y / i).
            Rounds resulting values to the nearest integer.
            </summary>
            <param name="c">The coordinate to divide by scalar.</param>
            <param name="i">The scalar to divide the coordinate by.</param>
            <returns>(c.X / i, c.Y / i), with the resulting values rounded to the nearest integer.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Division(GoRogue.Coord,System.Double)">
            <summary>
            / operator. Similar to int version.
            </summary>
            <param name="c">The coordinate to divide by scalar.</param>
            <param name="i">The scalar to divide the coordinate by.</param>
            <returns>(c.X / i, c.Y / i), with the resulting values rounded to the nearest integer.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            + operator. Returns the coordinate (c1.X + c2.X, c1.Y + c2.Y).
            </summary>
            <param name="c1">The first coordinate.</param>
            <param name="c2">The coordinate to add to c1.</param>
            <returns>c1 + c2, eg. (c1.X + c2.X, c1.Y + c2.Y)</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,System.Int32)">
            <summary>
            + operator. Adds scalar i to the x and y values of c; eg., returns (c.X + i, c.Y + i).
            </summary>
            <param name="c">Coordinate to add scalar to.</param>
            <param name="i">Scalar to add to coordinate.</param>
            <returns>Coordinate resulting from adding scalar i to x-value and y-value of c1.</returns>
        </member>
        <member name="M:GoRogue.Coord.op_Addition(GoRogue.Coord,GoRogue.Direction)">
            <summary>
            + operator. Translates the given coordinate by the given direction, eg. returns (c.X +
            d.DeltaX, c.Y + d.DeltaY).
            </summary>
            <param name="c">The coordinate to translate by the given direction.</param>
            <param name="d">The direction to translate the coordinate by.</param>
            <returns>
            The coordinate translated by the given direction, eg. (c.X + d.DeltaX, c.Y + d.DeltaY
            </returns>
        </member>
        <member name="M:GoRogue.Coord.op_Equality(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            True if c1.X == c2.X and c1.Y == c2.Y.
            </summary>
            <param name="c1">First coodinate to compare.</param>
            <param name="c2">Second coordinate to compare.</param>
            <returns>True if the two coordinates are equal, false if not.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToCoord(System.Int32,System.Int32)">
            <summary>
            Reverses the ToIndex function, returning the Coord represented by a given index.
            </summary>
            <param name="index">The index in 1D form.</param>
            <param name="width">The width of the 2D array.</param>
            <returns>The Coord represented by the 1D index given.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToIndex(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns y * width + x. Same as Coord.ToIndex(int width), just takes x and y instead.
            </summary>
            <param name="x">X-value of the coordinate.</param>
            <param name="y">Y-value of the coordinate.</param>
            <param name="width">The width of the 2D array, used to do math to calculate index.</param>
            <returns>The 1D index of this Coord.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToXValue(System.Int32,System.Int32)">
            <summary>
            Reverses the ToIndex function, returning only the X-value for the given index.
            </summary>
            <param name="index">The index in 1D form.</param>
            <param name="width">The width of the 2D array.</param>
            <returns>The X-value for the location represented by the given index.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToYValue(System.Int32,System.Int32)">
            <summary>
            Reverses the ToIndex function, returning only the Y-value for the given index.
            </summary>
            <param name="index">The index in 1D form.</param>
            <param name="width">The width of the 2D array.</param>
            <returns>The Y-value for the location represented by the given index.</returns>
        </member>
        <member name="M:GoRogue.Coord.Equals(System.Object)">
            <summary>
            Same as operator == in this case; returns false if obj is not a Coord.
            </summary>
            <param name="obj">The object to compare the current Coord to.</param>
            <returns>
            True if o is a Coord instance, and the two coordinates are equal, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Coord.GetHashCode">
            <summary>
            Returns a hash code for the Coord. The important parts: it should be fairly fast and it
            does not collide often. The details: it uses a seperate bit-mixing algorithm for X and Y,
            with X and Y each multiplied by a differet large integer, then xors the mixed values, and
            does a right shift, then multiplies by an overflowing prime number.
            </summary>
            <returns>The hash-code for the Coord.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToIndex(System.Int32)">
            <summary>
            Returns a value that can be used to index this location in a 2D array that is actually
            encoded in a 1D array. Actual value is Y * width + X. The 2D array being represented
            should have [width, height] of [width, anyValue] for this index to be valid. Note that,
            when this method is used, if one needs to use a nested for loop to iterate over this
            array, it is best to do for y... as the outer loop and for x..., as the inner loop, for
            cache performance reasons.
            </summary>
            <param name="width">The width of the 2D array, used to do math to calculate index.</param>
            <returns>The 1D index of this Coord.</returns>
        </member>
        <member name="M:GoRogue.Coord.ToString">
            <summary>
            Returns representation (X, Y).
            </summary>
            <returns>String (X, Y)</returns>
        </member>
        <member name="M:GoRogue.Coord.Translate(System.Int32,System.Int32)">
            <summary>
            Returns the coordinate resulting from adding dx to the X-value of the coordinate, and dy
            to the Y-value of the coordinate, eg. (X + dx, Y + dy). Provided for convenience.
            </summary>
            <param name="dx">Delta x to add to coordinate.</param>
            <param name="dy">Delta y to add to coordinate.</param>
            <returns>The coordinate (X + dx, Y + dy)</returns>
        </member>
        <member name="M:GoRogue.Coord.Translate(GoRogue.Coord)">
            <summary>
            Returns the coordinate resulting from adding dx to the X-value of the coordinate, and dy
            to the Y-value of the coordinate, eg. (X + dx, Y + dy). Provided for convenience.
            </summary>
            <param name="deltaChange">
            Vector where deltaChange.X represents the delta-x value and deltaChange.Y represents the
            delta-y value.
            </param>
            <returns>The coordinate (X + deltaChange.X, Y + deltaChange.Y)</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Dice">
            <summary>
            The most important DiceNotation class -- contains functions to roll dice, and to retrieve an
            IDiceExpression instance representing a given expression (useful and more efficient if a dice
            roll is used multiple times).
            </summary>
        </member>
        <member name="F:GoRogue.DiceNotation.Dice.DiceParser">
            <summary>
            The parser that will be used to parse dice expressions given to the Parse and Roll functions.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Dice.Parse(System.String)">
            <summary>
            Uses the IParser specified in the DiceParser variable to produce a IDiceExpression
            instance representing the given dice expression.
            </summary>
            <remarks>
            Because parsing can add significant time, retrieving an IDiceExpression instance instead
            of using the Roll function can be useful if a given expression will be rolled multiple times.
            </remarks>
            <param name="expression">The string dice expression to parse.</param>
            <returns>An IDiceExpression instance representing the parsed string.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Dice.Roll(System.String,Troschuetz.Random.IGenerator)">
            <summary>
            Uses the IParser specified in the DiceParser variable to parse the given dice expression,
            roll it, and return the result.
            </summary>
            <remarks>
            While more convenient, parsing is computationally more expensive than evaluation. If a
            dice expression will be rolled many times, it is more efficient to use the Parse method
            once, and use the resulting IDiceExpression instance to roll the expression each time it
            is needed.
            </remarks>
            <param name="expression">The string dice expression to parse.</param>
            <param name="random">
            RNG to use to perform the roll. If null is specified, the default RNG is used.
            </param>
            <returns>The result of evaluating the dice expression given.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.DiceExpression">
            <summary>
            The default class for representing a parsed dice expression.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.#ctor(GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the last term in the dice expression (the root of the expression tree).
            </summary>
            <param name="termToEvaluate">
            The root of the expression tree -- by evaluating this term, all others will be evaluated recursively.
            </param>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.MaxRoll">
            <summary>
            Returns the maximum possible result of the dice expression.
            </summary>
            <returns>The minimum possible result of the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.MinRoll">
            <summary>
            Returns the minimum possible result of the dice expression.
            </summary>
            <returns>The maximum possible result of the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.Roll(Troschuetz.Random.IGenerator)">
            <summary>
            Rolls the expression using the RNG given, returning the result.
            </summary>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <returns>The result obtained by rolling the dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.DiceExpression.ToString">
            <summary>
            Returns a parenthesized string representing the dice expression in dice notation
            </summary>
            <returns>A paranethesized string representing the expression.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.ImpossibleDieException">
            <summary>
            Exception that is thrown when a die is attempted to be constructed with an invalid number of sides.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.ImpossibleDieException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and the exception that caused this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidChooseException">
            <summary>
            Exception that is thrown when a dice term is constructed with a 'k' choose operation to keep
            an invalid number of dice.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidChooseException.#ctor(System.String,System.Exception)">
            <summary>
            Constructur, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException">
            <summary>
            Exception that is thrown when a dice term is constructed with a negative number of dice.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidMultiplicityException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException">
            <summary>
            Exception that is thrown when a the syntax of a dice notation string is determined to be invalid.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor(System.String)">
            <summary>
            Constructor, taking a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Exceptions.InvalidSyntaxException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor, taking a specified error message and a reference to the inner exception that
            is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter
            is not a null reference, the current exception is raised in a catch block that handles
            the inner exception.
            </param>
        </member>
        <member name="T:GoRogue.DiceNotation.IDiceExpression">
            <summary>
            Interface for class representing a parsed dice expression. Returned by IParser implementations.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.IDiceExpression.MaxRoll">
            <summary>
            Returns the maximum possible result of the dice expression (the highest it could be).
            </summary>
            <remarks>
            Typically this can be implemented by calling Roll and passing in a MaxRandom instance.
            </remarks>
            <returns>The maxiumum possible value that could be returned by this dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.IDiceExpression.MinRoll">
            <summary>
            Returns the minimum possible result of the dice expression (the lowest it could be).
            </summary>
            <remarks>
            Typically this can be implemented by calling Roll and passing in a MinRandom instance.
            </remarks>
            <returns>The miniumum possible value that could be returned by this dice expression.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.IDiceExpression.Roll(Troschuetz.Random.IGenerator)">
            <summary>
            Rolls the expression using the RNG given, returning the result.
            </summary>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <returns>The result obtained by rolling the dice expression.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.IParser">
            <summary>
            Interface for a class that parses a string representing a dice expression into a
            IDiceExpression instance.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.IParser.Parse(System.String)">
            <summary>
            Parses the dice expression spcified into an IDiceExpression instance.
            </summary>
            <param name="expression">The expression to parse.</param>
            <returns>
            An IDiceExpression representing the given expression, that can "roll" the expression on command.
            </returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Parser">
            <summary>
            Default class for parsing a string representing a dice expression into an IDiceExpression instance.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Parser.Parse(System.String)">
            <summary>
            Parses the dice expression spcified into an IDiceExpression instance.
            </summary>
            <remarks>
            Breaks the dice expression into postfix form, and evaluates the postfix expression to the
            degree necessary to produce the appropriate chain of ITerm instances.
            </remarks>
            <param name="expression">The expression to parse.</param>
            <returns>
            An IDiceExpression representing the given expression, that can "roll" the expression on command.
            </returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.AddTerm">
            <summary>
            Term representing the addition operator -- adds two terms together.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to add.
            </summary>
            <param name="term1">Left-hand side.</param>
            <param name="term2">Right-hand side.</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.AddTerm.Term1">
            <summary>
            First term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.AddTerm.Term2">
            <summary>
            Second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Adds its two terms together, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to use, passed to other terms.</param>
            <returns>The result of adding Term1 and Term2.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.AddTerm.ToString">
            <summary>
            Converts to a parenthesized string.
            </summary>
            <returns>A parenthesized string representing the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.ConstantTerm">
            <summary>
            Base term -- represents a numerical constant.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.#ctor(System.Int32)">
            <summary>
            Constructor. Takes the numerical constant it represents.
            </summary>
            <param name="value">The numerical value this term represents.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Returns the numerical constant it represents. RNG is unused.
            </summary>
            <param name="rng">(Unused) rng.</param>
            <returns>The numerical constant this term represents.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ConstantTerm.ToString">
            <summary>
            Returns a string representation of this constant.
            </summary>
            <returns>The numerical constant being represented, as a string.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.DiceTerm">
            <summary>
            Represents a dice term, eg 1d4 or 2d6.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the terms representing multiplicity and number of sides.
            </summary>
            <param name="multiplicity">
            Term representing the number of dice being rolled -- 2d6 has multiplicity 2.
            </param>
            <param name="sides">
            Term representing the number of sides the dice have -- 2d6 has 6 sides.
            </param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.DiceResults">
            <summary>
            An enumerable of integers representing the result of each dice roll. The expression 2d6
            rolls 2 dice, and as such this enumerable would be of length 2 and contain the result of
            each individual die.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.LastMultiplicity">
            <summary>
            The result of evaluating the Multiplicity term that was used during the last call to GetResult.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.LastSidedness">
            <summary>
            The result of evaluating the Sides term that was used during the last call to GetResult.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.Multiplicity">
            <summary>
            Term representing the number of dice being rolled -- 2d6 has multiplicity 2.
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DiceTerm.Sides">
            <summary>
            Term representing the number of sides the dice have -- 2d6 has 6 sides.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Rolls the dice, returning the sum.
            </summary>
            <param name="rng">The RNG to use for rolling,</param>
            <returns>The sum of the roll.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DiceTerm.ToString">
            <summary>
            Gets a parenthesized string representation of the dice term, eg (2d6).
            </summary>
            <returns>A parenthesized representation of the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.DivideTerm">
            <summary>
            Term representing the division operator -- divides the first term by the second.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to divide.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (right-hand side).</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DivideTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.DivideTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Divides the first term by the second, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating Term1 / Term2.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.DivideTerm.ToString">
            <summary>
            Returns a parenthesized string representing the operation.
            </summary>
            <returns>A parenthesized string representing the operation.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.ITerm">
            <summary>
            Interface for an evaluatable term of a dice expression.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.ITerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Evaluates the term and returns the result.
            </summary>
            <param name="rng">The rng to use.</param>
            <returns>The result of evaluating the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.KeepTerm">
            <summary>
            Term represnting the keep operator -- keeping only the n highest dice from a dice term.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.DiceTerm)">
            <summary>
            Constructor. Takes a term representing the number of dice to keep, and the dice term to
            operate on.
            </summary>
            <param name="keep">Term representing the number of dice to keep.</param>
            <param name="diceTerm">The dice term to operate on.</param>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Evaluates the term (as well as the dice expression), returning the sum of the highest n
            rolls in the dice term.
            </summary>
            <param name="rng">The rng to use -- passed to the dice term being operated on.</param>
            <returns>
            The sum of the highest n rolls of the dice term being operated on, where n is equal to
            the value of the keep variable taken in the constructor.
            </returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.KeepTerm.ToString">
            <summary>
            Returns a parenthesized string representing the term -- eg (4d6k3) or (2d6k2)
            </summary>
            <returns>A parenthesized string representing the term</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.MultiplyTerm">
            <summary>
            Term representing the division operator -- multiplies Term1 and Term2.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the terms that will be multiplied.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second ter (left-hand side).</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.MultiplyTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Multiplies the first term by the second, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating Term1 * Term2.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.MultiplyTerm.ToString">
            <summary>
            Returns a parenthesized string representing the term.
            </summary>
            <returns>A parenthesized string representing the term.</returns>
        </member>
        <member name="T:GoRogue.DiceNotation.Terms.SubtractTerm">
            <summary>
            Term representing the subtraction operator -- subtracts the second term from the first.
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.#ctor(GoRogue.DiceNotation.Terms.ITerm,GoRogue.DiceNotation.Terms.ITerm)">
            <summary>
            Constructor. Takes the two terms to subtract.
            </summary>
            <param name="term1">The first term (left-hand side).</param>
            <param name="term2">The second term (right-hand side).</param>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.SubtractTerm.Term1">
            <summary>
            The first term (left-hand side).
            </summary>
        </member>
        <member name="P:GoRogue.DiceNotation.Terms.SubtractTerm.Term2">
            <summary>
            The second term (right-hand side).
            </summary>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.GetResult(Troschuetz.Random.IGenerator)">
            <summary>
            Subtracts the second term from the first, evaluating those two terms as necessary.
            </summary>
            <param name="rng">The rng to used -- passed to other terms.</param>
            <returns>The result of evaluating Term1 - Term2.</returns>
        </member>
        <member name="M:GoRogue.DiceNotation.Terms.SubtractTerm.ToString">
            <summary>
            Returns a parenthesized string representing the operation.
            </summary>
            <returns>A parenthesized string representing the operation.</returns>
        </member>
        <member name="T:GoRogue.Direction">
            <summary>
            Utility class to handle Directions on a grid map. The built-in variables hold the dx and dy
            for that direction, at unit scale.
            </summary>
            <remarks>
            It also contains functions to provide ways to iterate over the directions in common orders --
            for example, it contains a function that returns an Enumerable of all the directions in
            clockwise order, as well as a similar function for cardinal directions in a clockwise order,
            among many others. It is also possible to invert the y coordinates (where UP is 0, 1 and DOWN
            is 0, -1, etc). Direction instances can also be added to Coords to produce the coordinate
            directly adjacent in the direction added.
            </remarks>
        </member>
        <member name="T:GoRogue.Direction.Types">
            <summary>
            Enum representing Direction types. Useful for easy mapping of Direction types to a
            primitive type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.UP">
            <summary>
            Type for Direction.UP.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.UP_RIGHT">
            <summary>
            Type for Direction.UP_RIGHT.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.RIGHT">
            <summary>
            Type for Direction.RIGHT.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.DOWN_RIGHT">
            <summary>
            Type for Direction.DOWN_RIGHT.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.DOWN">
            <summary>
            Type for Direction.DOWN.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.DOWN_LEFT">
            <summary>
            Type for Direction.DOWN_LEFT.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.LEFT">
            <summary>
            Type for Direction.LEFT.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.UP_LEFT">
            <summary>
            Type for Direction.UP_LEFT.
            </summary>
        </member>
        <member name="F:GoRogue.Direction.Types.NONE">
            <summary>
            Type for Direction.NONE.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DOWN">
            <summary>
            Down direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DOWN_LEFT">
            <summary>
            Down-left direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DOWN_RIGHT">
            <summary>
            Down-right direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.LEFT">
            <summary>
            Left direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.NONE">
            <summary>
            No direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.RIGHT">
            <summary>
            Right direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.UP">
            <summary>
            Up direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.UP_LEFT">
            <summary>
            Up-left direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.UP_RIGHT">
            <summary>
            Up-right direction.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.YIncreasesUpward">
            <summary>
            Whether or not a positive y-value indicates an UP motion. If true, Directions with an UP
            component will have positive y-values, and ones with DOWN components will have negative
            values. Setting this to false (which is the default) inverts this.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DeltaX">
            <summary>
            Delta X for direction. Right is positive, left is negative.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.DeltaY">
            <summary>
            Delta Y for direction. Down is positive, up is negative, since this is how graphics
            coordinates typically work.
            </summary>
        </member>
        <member name="P:GoRogue.Direction.Type">
            <summary>
            Enum type corresponding to Direction being represented.
            </summary>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of the given
            line. Rounds clockwise if the heading is exactly on a diagonal direction. Similar to
            GetDirection, except gives only cardinal directions.
            </summary>
            <param name="start">Starting coordinate of the line.</param>
            <param name="end">Ending coordinate of the line.</param>
            <returns>
            The cardinal direction that most closely matches the heading formed by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of the given
            line. Rounds clockwise if the heading is exactly on a diagonal direction. Similar to
            GetDirection, except gives only cardinal directions.
            </summary>
            <param name="startX">X-coordinate of the starting position of the line.</param>
            <param name="startY">Y-coordinate of the starting position of the line.</param>
            <param name="endX">X-coordinate of the ending position of the line.</param>
            <param name="endY">Y-coordinate of the ending position of the line.</param>
            <returns>
            The cardinal direction that most closely matches the heading formed by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(GoRogue.Coord)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of a line
            with the given dx and dy values. Rounds clockwise if exactly on a diagonal. Similar to
            GetDirection, except gives only cardinal directions.
            </summary>
            <param name="deltaChange">
            Vector representing the change in x and change in y across the line (deltaChange.X is the
            change in x, deltaChange.Y is the change in y).
            </param>
            <returns>
            The cardinal direction that most closely matches the degree heading of the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetCardinalDirection(System.Int32,System.Int32)">
            <summary>
            Returns the cardinal direction that most closely matches the degree heading of a line
            with the given dx and dy values. Rounds clockwise if exactly on a diagonal direction.
            Similar to GetDirection, except gives only cardinal directions.
            </summary>
            <param name="dx">The change in x-values across the line.</param>
            <param name="dy">The change in x-values across the line.</param>
            <returns>
            The cardinal direction that most closely matches the degree heading of the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the direction that most closely matches the degree heading of the given line.
            Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="start">Starting coordinate of the line.</param>
            <param name="end">Ending coordinate of the line.</param>
            <returns>
            The direction that most closely matches the heading formed by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the direction that most closely matches the degree heading of the given line.
            Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="startX">X-coordinate of the starting position of the line.</param>
            <param name="startY">Y-coordinate of the starting position of the line.</param>
            <param name="endX">X-coordinate of the ending position of the line.</param>
            <param name="endY">Y-coordinate of the ending position of the line.</param>
            <returns>
            The direction that most closely matches the heading formed by the given line.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(GoRogue.Coord)">
            <summary>
            Returns the direction that most closely matches the degree heading of a line with the
            given delta-x and delta-y values. Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="deltaChange">
            Vector representing the change in x and change in y across the line (deltaChange.X is the
            change in x, deltaChange.Y is the change in y).
            </param>
            <returns>
            The direction that most closely matches the heading formed by the given input.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.GetDirection(System.Int32,System.Int32)">
            <summary>
            Returns the direction that most closely matches the degree heading of a line with the
            given delta-x and delta-y values. Rounds clockwise if the heading is exactly between two directions.
            </summary>
            <param name="dx">The change in x-values across the line.</param>
            <param name="dy">The change in y-values across the line.</param>
            <returns>
            The direction that most closely matches the heading formed by the given input.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Subtraction(GoRogue.Direction,System.Int32)">
            <summary>
            - operator. Returns the direction i directions counterclockwise of the given direction if
            i is positive. If is negative, the direction is moved clockwise. If any amount is added
            to NONE, it returns NONE.
            </summary>
            <param name="d">Direction to "subtract" from.</param>
            <param name="i">Number of directions to "subtract".</param>
            <returns>
            The direction i directions counterclockwise of d, if i is positive, or clockwise of d if
            i is negative. NONE is returned if NONE was added to.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Decrement(GoRogue.Direction)">
            <summary>
            -- operator (decrement). Returns the direction directly counterclockwise of the original
            direction. If NONE is decremented, returns NONE.
            </summary>
            <param name="d">Direction to decrement.</param>
            <returns>The direction directly counterclockwise of d, or NONE if none was decremented.</returns>
        </member>
        <member name="M:GoRogue.Direction.op_Addition(GoRogue.Direction,System.Int32)">
            <summary>
            + operator. Returns the direction i directions clockwise of the given direction if i is
            positive. If is negative, the direction is moved counterclockwise. If any amount is added
            to NONE, it returns NONE.
            </summary>
            <param name="d">Direction to "add" to.</param>
            <param name="i">Number of directions to "add".</param>
            <returns>
            The direction i directions clockwise of d, if i is positive, or counterclockwise of d if
            i is negative. NONE is returned if NONE was added to.
            </returns>
        </member>
        <member name="M:GoRogue.Direction.op_Increment(GoRogue.Direction)">
            <summary>
            ++ operator (increment). Returns the direction directly clockwise of the original
            direction. If NONE is incremented, returns NONE.
            </summary>
            <param name="d">Direction to increment.</param>
            <returns>The direction directly clockwise of d, or NONE if none is incremented.</returns>
        </member>
        <member name="M:GoRogue.Direction.ToDirection(GoRogue.Direction.Types)">
            <summary>
            Gets the Direction class instance representing the direction type specified.
            </summary>
            <param name="directionType">The enum value for the direction.</param>
            <returns>The direction class representing the given direction.</returns>
        </member>
        <member name="M:GoRogue.Direction.ToString">
            <summary>
            Writes the string ("UP", "UP_RIGHT", etc.) for the direction.
            </summary>
            <returns>String representation of the direction.</returns>
        </member>
        <member name="T:GoRogue.DisjointSet">
            <summary>
            Basic representation of a Disjoint set data structure. Assumes it is holding integers between
            0 and size - 1.
            </summary>
        </member>
        <member name="M:GoRogue.DisjointSet.#ctor(System.Int32)">
            <summary>
            Constructor. Size of disjoint set is specified -- it holds values between 0 and size - 1.
            </summary>
            <param name="size">(Max) size of the disjoint set.</param>
        </member>
        <member name="P:GoRogue.DisjointSet.Count">
            <summary>
            Number of distinct sets.
            </summary>
        </member>
        <member name="M:GoRogue.DisjointSet.AsReadOnly">
            <summary>
            Returns a read-only representation of the disjoint set.
            </summary>
            <returns>A read-only representation of the disjoint set.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.Find(System.Int32)">
            <summary>
            Returns the parent of the set containing obj, performing path compression as search is completed.
            </summary>
            <param name="obj">Object to search for.</param>
            <returns>The parent of the obj given.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.InSameSet(System.Int32,System.Int32)">
            <summary>
            Returns true if the two objects specified are in the same set.
            </summary>
            <param name="obj1">First object.</param>
            <param name="obj2">Second object.</param>
            <returns>True if the two objects are in the same set, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.DisjointSet.MakeUnion(System.Int32,System.Int32)">
            <summary>
            Performs a union of the sets containing the two objects specified. After this operation,
            every element in the sets containing the two objects specified will be part of one larger set.
            </summary>
            <remarks>If the two elements are already in the same set, nothing is done.</remarks>
            <param name="obj1">First object.</param>
            <param name="obj2">Second object.</param>
        </member>
        <member name="M:GoRogue.DisjointSet.ToString">
            <summary>
            Returns a string representation of the DisjointSet, showing parents and all elements in
            their set.
            </summary>
            <returns>A string representation of the DisjointSet.</returns>
        </member>
        <member name="T:GoRogue.Distance">
            <summary>
            Class representing a method of calculating distance. You cannot create instances of this
            class using a constructor -- instead this class contains static instances representing the
            applicable types of distance calculations.
            </summary>
            <remarks>
            Provides functions that calculate the distance between two points according to the distance
            measurement being used. Distance instances can also be explicitly casted to Radius instances
            -- the 2D radius shape that corresponds to the shape of a "radius" according to the casted
            distance calculation is retrieved (eg, EUCLIDEAN casts to CIRCLE, MANHATTAN to DIAMOND, etc.)
            </remarks>
        </member>
        <member name="F:GoRogue.Distance.CHEBYSHEV">
            <summary>
            CHEBYSHEV distance (equivalent to 8-way movement with no extra cost for diagonals).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.EUCLIDEAN">
            <summary>
            EUCLIDEAN distance (equivalent to 8-way movement with extra cost for diagonals).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.MANHATTAN">
            <summary>
            MANHATTAN distance (equivalent to 4-way, cardinal-only movement).
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Type">
            <summary>
            Enum type for the distance calculation. Useful for conducting a switch statement on
            distance instances.
            </summary>
        </member>
        <member name="T:GoRogue.Distance.Types">
            <summary>
            Enum for types used under the hood in Direction classes -- allows for convenient switch
            statements to be used with respect to directions.
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Types.MANHATTAN">
            <summary>
            Enum type for Distance.MANHATTAN.
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Types.EUCLIDEAN">
            <summary>
            Enum type for Distance.EUCLIDEAN.
            </summary>
        </member>
        <member name="F:GoRogue.Distance.Types.CHEBYSHEV">
            <summary>
            Enum type for Distance.CHEBYSHEV.
            </summary>
        </member>
        <member name="M:GoRogue.Distance.op_Explicit(GoRogue.Distance)~GoRogue.Radius">
            <summary>
            Allows explicit casting to Radius type. The 2D radius shape corresponding to the
            definition of a radius according to the distance calculation casted will be retrieved.
            </summary>
            <param name="distance">Distance type being casted.</param>
        </member>
        <member name="M:GoRogue.Distance.op_Implicit(GoRogue.Distance)~GoRogue.AdjacencyRule">
            <summary>
            Allows implicit casting to the AdjacencyRule type. The adjacency rule corresponding to
            the definition of a radius according to the distance calculation casted will be retrieved.
            </summary>
            <param name="distance">Distance type being casted.</param>
        </member>
        <member name="M:GoRogue.Distance.ToDistance(GoRogue.Distance.Types)">
            <summary>
            Gets the Distance class instance representing the distance type specified.
            </summary>
            <param name="distanceType">The enum value for the distance method.</param>
            <returns>The distance class representing the given distance calculation.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the distance between the two (3D) points specified.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="startZ">Z-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <param name="endZ">Z-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between the two (3D) points specified. Points are floating point
            instead of integer-values.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="startZ">Z-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <param name="endZ">Z-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the distance between the two (2D) points specified.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Returns the distance between the two (2D) points specified.
            </summary>
            <param name="start">Starting point.</param>
            <param name="end">Ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between the two (2D) points specified. Points are floating point
            instead of integer-values.
            </summary>
            <param name="startX">X-Coordinate of the starting point.</param>
            <param name="startY">Y-Coordinate of the starting point.</param>
            <param name="endX">X-Coordinate of the ending point.</param>
            <param name="endY">Y-Coordinate of the ending point.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(GoRogue.Coord)">
            <summary>
            Returns the distance between two locations, given the change in X and change in Y value
            (specified by the X and Y values of the coordinate.
            </summary>
            <param name="end">The delta-x and delta-y between the two locations.</param>
            ///
            <returns>The distance between the two locations.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32)">
            <summary>
            Returns the distance between two locations, given the change in X and change in Y value.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <returns>The distance between the two locations.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double)">
            <summary>
            Returns the distance between two locations, given the change in X and change in Y value.
            The change in X and Y are specified as floating point values rather than integers.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <returns>The distance between the two locations.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the distance between two locations, given the change in X, Y, and Z value.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <param name="dz">The delta-z between the two locations.</param>
            <returns>The distance between the two locations.</returns>
        </member>
        <member name="M:GoRogue.Distance.Calculate(System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance between two locations, given the change in X, Y, and Z value. The
            change in X, Y, and Z are specified as floating point values rather than integers.
            </summary>
            <param name="dx">The delta-x between the two locations.</param>
            <param name="dy">The delta-y between the two locations.</param>
            <param name="dz">The delta-z between the two locations.</param>
            <returns>The distance between the two locations.</returns>
        </member>
        <member name="M:GoRogue.Distance.ToString">
            <summary>
            Returns a string representation of the Distance.
            </summary>
            <returns>A string representation of the Distance.</returns>
        </member>
        <member name="T:GoRogue.EffectArgs">
            <summary>
            Default argument for any effect. Any class that is used as the template argument for an
            effect must either be this or a class that inherits from this.
            </summary>
            <remarks>This allows cancellation of EffectTriggers, as detailed in that class's documentation.</remarks>
        </member>
        <member name="F:GoRogue.EffectArgs.CancelTrigger">
            <summary>
            Whether or not the EffectTrigger should stop calling all subsequent effect's Trigger
            functions. See that class's documentation for details.
            </summary>
        </member>
        <member name="M:GoRogue.EffectArgs.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:GoRogue.Effect`1">
            <summary>
            Class designed to represent any sort of in-game effect. This could be anything from a simple
            physical damage effect to a heal effect, including area of effects, damage over time effects,
            or even potentially a special effect that simply boosts a stat.
            </summary>
            <remarks>
            Effectively, the class is nothing more than an interface for the concept of something that
            happens, potentially instantaneously or potentially one or more times on a certain event
            (beginning of a turn, end of a turn, on taking damage, etc). The standard way to use the
            Effect class is to create a subclass of Effect, that at the very least implements the
            OnTrigger function, which should accomplish whatever the effect should do when it is
            triggered. The subclass can specify what parameter(s) it needs to take in via the class's
            type parameter. If multiple arguments are needed, one should create a class that subclasses
            EffectArgs that contains all the parameters, and the effect subclass should then take an
            instance of that EffectArgs subclass as the single parameter. If no arguments are needed,
            then one may pass null as the parameter to Trigger. The concept of a duration is also
            built in to the interface (see EffectTrigger class for details on Effect durations. The
            duration is to be interpreted as the number of times the effect's Trigger function will be
            called before it will be removed from an EffectTrigger. If the effect is instantaneous,
            eg. it happens only when Trigger is called, on no particular event (such as a simple instant
            physical damage effect), then the duration specified in the constructor should be the static
            class constant INSTANT. Otherwise, one may specify the duration as a positive integer, or the
            INFINITE static class constant. See EffectTrigger class documentation for details on durations.
            </remarks>
            <typeparam name="TriggerArgs">
            The type of the parameter that will be specified to the Trigger function when called.
            </typeparam>
        </member>
        <member name="F:GoRogue.Effect`1.INFINITE">
            <summary>
            The value one should specify as the effect duration for an infinite effect, eg. an effect
            that will never expire and be automatically removed from an EffectTrigger.
            </summary>
        </member>
        <member name="F:GoRogue.Effect`1.INSTANT">
            <summary>
            The value one should specify as the effect duaration for an instantaneous effect, eg. an
            effect that only occurs when Trigger is manually called, and thus cannot be added to an EffectTrigger.
            </summary>
        </member>
        <member name="P:GoRogue.Effect`1.Name">
            <summary>
            The name of the effect
            </summary>
        </member>
        <member name="P:GoRogue.Effect`1.Duration">
            <summary>
            The duration of the effect. When the duration reaches 0, the Effect will be automatically
            removed from an EffectTrigger. The duration can be changed from a subclass, which can be
            used in OnTrigger to cause an effect to be "cancelled", eg. immediately expire, or to
            extend/reduce its duration.
            </summary>
        </member>
        <member name="E:GoRogue.Effect`1.Expired">
            <summary>
            Fires as soon as the effect is about to expire.  Fires after the OnTrigger has been called that round,
            but before it is removed from any EffectTriggers.
            </summary>
        </member>
        <member name="M:GoRogue.Effect`1.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="name">Name for the effect</param>
            <param name="startingDuration">Starting duration for the effect.</param>
        </member>
        <member name="M:GoRogue.Effect`1.Trigger(`0)">
            <summary>
            Should be called on instantaneous effects to Trigger the effect. Can also be called
            manually (not by an EffectTrigger) on non-instantaneous effects, however note that it
            will still cause the duration to decrease.
            </summary>
            <remarks>
            Any effect that has INSTANT duration (eg. duration 0) will still have OnTrigger called
            when Trigger is called.
            </remarks>
            <param name="args">Parameters that are passed to OnTrigger. Can be null.</param>
        </member>
        <member name="M:GoRogue.Effect`1.OnTrigger(`0)">
            <summary>
            Should be implemented to take whatever action(s) the effect is supposed to accomplish.
            This function is called automatically when Trigger is called.
            </summary>
            <param name="e">Class containing all arguments OnTrigger requires to function.</param>
        </member>
        <member name="M:GoRogue.Effect`1.ToString">
            <summary>
            Yields a string of the effect's name and duration.
            </summary>
            <returns>String representation of the effect.</returns>
        </member>
        <member name="T:GoRogue.EffectTrigger`1">
            <summary>
            Represents an "event" that can trigger one or more Effects of the appropriate type. Typically
            instnaces of this class can simply be created, however a subclass may be required for custom
            add/remove actions and ordering.
            </summary>
            <remarks>
            EffectTrigger's primary purpose is to represent an event that can trigger one or more effects
            automatically, and manage the automatic removal of those effects when their duration reaches
            0. /// Each EffectTrigger instance can have one or more non-instantaneous effects added to
            it. All Effects must take the same type of argument to their Trigger function, as specified
            by this class's TriggerArgs type parameter. /// Each time the EffectTrigger's TriggerEffects
            function is called, every added Effect has its Trigger function called (provided its duration
            is not 0). Each Effect may, via the TriggerArgs CancelTrigger member, stop the effect from
            being sent to subsequent Effects in the EffectTrigger's list. /// Once all effects have had
            Trigger called as applicable, or some effect has cancelled the trigger, any effect whose
            duration has reached 0 is removed from the EffectTrigger automatically. /// Typically, one
            instance of this class is created per "event" that can trigger effects, and then the
            instance's TriggerEffects function is called whenever that event happens. For example, in a
            typical roguelike, all damageable creatures might have an instance of this class called
            OnDamageTaken. Any effect that should trigger when that creature takes damage would then be
            added to that creature's OnDamageTaken EffectTrigger. The TakeDamage function of that
            creature would then need to call OnDamageTaken.TriggerEffects(...). In this way, all effects
            added to the OnDamageTaken EffectTrigger would be triggered automatically whenever the
            creature takes damage. /// For some complex game mechanics, it may be desireable to control
            how effects stack, the order they appear in the Effects list of EffectTriggers, etc. In these
            cases, subclassing EffectTrigger and overriding add/remove can allow this functionality.
            </remarks>
            <typeparam name="TriggerArgs">
            The type of argument that must be accepted by the Trigger function of any Effect added to
            this EffectTrigger.
            </typeparam>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:GoRogue.EffectTrigger`1.Effects">
            <summary>
            List of all effects that are part of this EffectTrigger.
            </summary>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.Add(GoRogue.Effect{`0})">
            <summary>
            Adds the given effect to this EffectTrigger, provided the effect's duration is not 0. If
            the effect's duration is 0, an ArgumentException is thrown.
            </summary>
            <param name="effect">The effect to add to this trigger.</param>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.Remove(GoRogue.Effect{`0})">
            <summary>
            Removes the given effect from this EffectTrigger.
            </summary>
            <param name="effect">The effect to remove</param>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.ToString">
            <summary>
            Yields a string representation of each effect that has been added to the effect trigger.
            </summary>
            <returns>
            A string representation of each effect that has been added to the effect trigger.
            </returns>
        </member>
        <member name="M:GoRogue.EffectTrigger`1.TriggerEffects(`0)">
            <summary>
            For each effect in the list, calls its Trigger function if its duration is not 0, then
            remvoes any effect that has duration 0.
            </summary>
            <remarks>
            The argument given is passed along to the Trigger function of each effect that has
            Trigger called. If some effect sets the CancelTrigger flag in the argument to true, the
            loop will be broken and no subsequent effects in the list will have Trigger called. After
            either this occurs or all effects have had Trigger called, any effect in the list that
            has a duration of 0 is automatically removed from the list. /// It is valid to pass null
            as the argument to this function, if the effects need no actual parameters.
            </remarks>
            <param name="args">Argument to pass to the Trigger function of each effect.</param>
        </member>
        <member name="T:GoRogue.FOV">
            <summary>
            Class responsible for caculating basic FOV (see SenseMap for more advanced lighting).
            Effectively a simplified, slightly faster interface compared to SenseMap, that supports only
            a single source and only shadowcasting. This is more conducive to the typical use case for
            FOV. It can calculate the FOV with a finite or infinite max radius, and can use a variety of
            radius types, as specified in Radius class (all the same ones that SenseMap supports). It
            also supports both 360 degree FOV and a "field of view" (cone) FOV. One may access this class
            like a 2D array of doubles (FOV values), wherein the values will range from 0.0 to 1.0, where
            1.0 means the corresponding map grid coordinate is at maximum visibility, and 0.0 means the
            cooresponding coordinate is outside of FOV entirely (not visible).  Values fall off linearly
            with respect to radius as distance from the center increases.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.BooleanFOV">
            <summary>
            A view of the FOV results in boolean form, where true indicates a location is in FOV, and false indicates it is not.
            </summary>
        </member>
        <member name="M:GoRogue.FOV.#ctor(GoRogue.MapViews.IMapView{System.Double})">
            <summary>
            Constructor.  Takes SenseMap-style resistance map as input data.
            </summary>
            <param name="resMap">
            The resistance map to use to calculate FOV. Values of 1.0 are considered blocking to FOV,
            while other (lower) values are considered to be not blocking.
            </param>
        </member>
        <member name="M:GoRogue.FOV.#ctor(GoRogue.MapViews.IMapView{System.Boolean})">
            <summary>
            Constructor.  Takes resistance map as a simple map view of boolean values, where true indicates
            the location is transparent (does NOT block FOV), and false indicates it is not transparent (does block FOV)
            </summary>
            <param name="resMap">The map to use for FOV calculation.</param>
        </member>
        <member name="P:GoRogue.FOV.CurrentFOV">
            <summary>
            IEnumerable of only positions currently in FOV.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.Height">
            <summary>
            Height of FOV map.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.NewlySeen">
            <summary>
            IEnumerable of positions that are in FOV as of the most current Calculate call, but were
            NOT in FOV afterthe previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.NewlyUnseen">
            <summary>
            IEnumerable of positions that are NOT in FOV as of the most current Calculate call, but
            WERE in FOV after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.Width">
            <summary>
            Width of FOV map.
            </summary>
        </member>
        <member name="P:GoRogue.FOV.Item(GoRogue.Coord)">
            <summary>
            Array-style indexer that takes a Coord as the index, and retrieves the FOV value at the
            given location.
            </summary>
            <param name="position">The position to retrieve the FOV value for.</param>
            <returns>The FOV value at the given location.</returns>
        </member>
        <member name="P:GoRogue.FOV.Item(System.Int32,System.Int32)">
            <summary>
            Array-style indexer that takes an x and y value as the index, and retrieves the FOV value
            at the given location.
            </summary>
            <param name="x">The x-coordinate of the position to retrieve the FOV value for.</param>
            <param name="y">The y-coordinate of the position to retrieve the FOV value for.</param>
            <returns>The FOV value at (x, y).</returns>
        </member>
        <member name="M:GoRogue.FOV.AsReadOnly">
            <summary>
            Returns a read-only representation of the fov.
            </summary>
            <returns>This fov object, exposed as an IReadOnlyFOV.</returns>
        </member>
        <member name="M:GoRogue.FOV.Calculate(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculates FOV, given an origin point of (startX, startY), with a given radius. If no
            radius is specified, simply calculates with a radius of maximum integer value, which is
            effectively infinite. Radius is computed as a circle around the source (type Radius.CIRCLE).
            </summary>
            <param name="startX">Coordinate x-value of the origin.</param>
            <param name="startY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of FOV if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(GoRogue.Coord,System.Double)">
            <summary>
            Calculates FOV, given an origin point, with a given radius. If no radius is specified,
            simply calculates with a radius of maximum integer value, which is effectively infinite.
            Radius is computed as a circle around the source (type Radius.CIRCLE).
            </summary>
            <param name="start">Position of FOV origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of FOV if completely unobstructed.
            If no radius is specified, it is effectively infinite.
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(System.Int32,System.Int32,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV, given an origin point of (startX, startY), with the given radius and
            radius calculation strategy.
            </summary>
            <param name="startX">Coordinate x-value of the origin.</param>
            <param name="startY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of FOV if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(GoRogue.Coord,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV, given an origin point, with the given radius and radius calculation strategy.
            </summary>
            <param name="start">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of FOV if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV, given an origin point of (startX, startY), with the given radius and
            radius calculation strategy, and assuming FOV is restricted to the area specified by the
            given angle and span, in degrees. Provided that span is greater than 0, a conical section
            of the regular FOV radius will be actually in FOV.
            </summary>
            <param name="startX">Coordinate x-value of the origin.</param>
            <param name="startY">Coordinate y-value of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of FOV if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the FOV cone. 0 degrees
            points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the FOV cone -- angle/2
            degrees are included on either side of the cone's center line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.Calculate(GoRogue.Coord,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV, given an origin point of (startX, startY), with the given radius and
            radius calculation strategy, and assuming FOV is restricted to the area specified by the
            given angle and span, in degrees. Provided that span is greater than 0, a conical section
            of the regular FOV radius will be actually in FOV.
            </summary>
            <param name="start">Coordinate of the origin.</param>
            <param name="radius">
            The maximum radius -- basically the maximum distance of FOV if completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
            <param name="angle">
            The angle in degrees that specifies the outermost center point of the FOV cone. 0 degrees
            points right.
            </param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the FOV cone -- angle/2
            degrees are included on either side of the span line.
            </param>
        </member>
        <member name="M:GoRogue.FOV.ToString(System.Char,System.Char)">
            <summary>
            ToString overload that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in FOV.</param>
            <param name="sourceValue">The character used for any location that is in FOV.</param>
            <returns>The string representation of FOV, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.FOV.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the FOV, rounded to
            the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>A string representation of FOV, rounded to the given number of decimal places.</returns>
        </member>
        <member name="M:GoRogue.FOV.ToString">
            <summary>
            Returns a string representation of the map, where any location not in FOV is represented
            by a '-' character, and any position in FOV is represented by a '+'.
            </summary>
            <returns>A (multi-line) string representation of the FOV.</returns>
        </member>
        <member name="T:GoRogue.GameFramework.GameObject`1">
            <summary>
            Base class for any object that has a grid position and can be added to a Map.  BaseSubclass must be the
            type that is deriving from this types, eg. class MyDerivingGameObject : GameObject&lt;MyDerivingGameObject&gt;
            </summary>
            <remarks>
            This class is designed to serve as a base class for your own game objects in your game.  It implements
            basic common functionality such as walkability and transparency, and provides some infrastructure
            that allows it to be added to instances of Map&lt;GameObject&lt;BaseSubclass&gt;&gt;.  It also implements
            the necessary functionality that allows GameObjects to be added to an ISpatialMap implementation.
            
            It is intended that you create a class (say, MyGameObject), that derives from this one (GameObject&lt;MyGameObject&gt;),
            and use this as the base class for your game's objects.  This way, a Map&lt;MyGameObject&gt; class will return
            its objects as type MyGameObject, meaning you can implement any common, game-specific functionality you need 
            and have easy access to that information when objects are retrieved from the map.
            </remarks>
            <typeparam name="BaseSubclass">Type of the class that is deriving from this one.</typeparam>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.Position">
            <summary>
            The position of this object on the grid. Any time this value is changed, the Moved event is fired.
            </summary>
            <remarks>
            This property may be overriden to implement custom functionality, however it is highly recommended
            that you call the base set in the overridden setter, as it performs collision detection.
            </remarks>
        </member>
        <member name="E:GoRogue.GameFramework.GameObject`1.Moved">
            <summary>
            Event fired whenever this object's grid position is successfully changed.  Fired regardless of whether
            the object is part of a Map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.IsWalkable">
            <summary>
            Whether or not the object is to be considered "walkable", eg. whether or not the square it resides
            on can be traversed by other, non-walkable objects on the same map.  Effectively, whether or not this
            object collides according to the collision layer.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.IsTransparent">
            <summary>
            Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of a Map's FOV.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.IsStatic">
            <summary>
            Whether or not the object is "static".  Static objects CANNOT be moved, and only static objects may
            be placed on a Map's layer 0.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.ID">
            <summary>
            ID of the object.  Used for the sake of putting instances of this class in ISpatialMap implementations,
            and is NOT guaranteed to be entirely unique, though this can be modified by overriding the GenerateID
            function.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.Layer">
            <summary>
            Layer of a Map that this object can reside on.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.GameObject`1.CurrentMap">
            <summary>
            The current Map which this object resides on.  Null if the object has not been assigned an object.
            A GameObject is allowed to reside on only one map.
            </summary>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject`1.#ctor(GoRogue.Coord,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="position">Position to start the object at.</param>
            <param name="layer">The layer of of a Map the object is assigned to.</param>
            <param name="isStatic">Whether or not the object can be moved (true if the object CANNOT be moved,
            false otherwise).</param>
            <param name="isWalkable">Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of a Map's FOV.</param>
            <param name="isTransparent">Whether or not the object is considered "transparent", eg. whether or not light passes through it
            for the sake of a Map's FOV.</param>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject`1.MoveIn(GoRogue.Direction)">
            <summary>
            Attempts to move the object in the given direction, and returns true if the objec was successfully
            moved, false otherwise.
            </summary>
            <param name="direction">The direction in which to try to move the object.</param>
            <returns>True if the object was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.GameObject`1.GenerateID">
            <summary>
            Function used at construction to assign an ID to the object.  
            </summary>
            <remarks>
            The default implementation simply assigns a random number in range of valid uints.  This is sufficiently distinct for the purposes of placing
            the objects in an ISpatialMap, however obviously does NOT guarantee true uniqueness.  If uniqueness or some other implementation is required,
            override this function to return an appropriate ID.  Bear in mind a relatively high degree of uniqueness is necessary for efficient placement
            in an ISpatialMap implementation.
            </remarks>
            <returns>An ID to assign to the current object.</returns>
        </member>
        <member name="T:GoRogue.GameFramework.Map`1">
            <summary>
            Base class for a map that consists of one or more objects of type BaseObject.  It implements basic functionality to manage these objects, as well as
            commonly needed functinonality like tile exploration, FOV, and pathfinding.  BaseObject must be a type that derives from
            GameObject&lt;BaseObject&gt;.
            </summary>
            <remarks>
            A Map consists of BaseObjects on one or more layers.  These layers are numbered, from the lowest layer of 0 upward.  Each Map contains at minimum a
            "terrain" layer.  This is considered to be layer 0.  All objects added to this layer must have their IsStatic flag set to true, and must reside
            on layer 0.
            
            A map will typically also have some other layers, for non terrain objects like the player, monsters, items, etc.  The number of these layers present
            on the map, along with which of all the layers participate in collision detection, etc., can be specified in the constructor.
            
            While this class has some flexibility, it does, unlike the rest of the library, tend to impose itself on your architecture.  In cases where this is
            undesireable, each component of this map class exists as a separate component (layer masking, the SpatialMap(s) storing the entity layers, FOV, and pathfinding
            all exist as their own (more flexible) components).  This class is not intended to cover every possible use case, but instead may act as an example or starting
            point in the case where you would like to use the components in a different way or within a different architecture.
            </remarks>
            <typeparam name="BaseObject">The class deriving from GameObject that this map will hold.</typeparam>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.Terrain">
            <summary>
            Terrain of the map.  Terrain at each location may be set via the SetTerrain function.
            </summary>
        </member>
        <member name="F:GoRogue.GameFramework.Map`1.Explored">
            <summary>
            Whether or not each tile is considered explored.  Tiles start off unexplored, and become explored as soon as they are within
            a calculated FOV.  This ArrayMap may also have values set to it, to easily allow for serialization or wizard-mode like functionality.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.Entities">
            <summary>
            IReadOnlyLayeredSpatialMap of all entities (non-terrain objects) on the map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.LayerMasker">
            <summary>
            LayerMasker that should be used to create layer masks for this Map.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.LayersBlockingWalkability">
            <summary>
            Layer mask that contains only layers that block walkability.  A non-walkable BaseObject can only be added to this map if the layer it is on is contained
            within this layer mask.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.LayersBlockingTransparency">
            <summary>
            Layer mask that contains only layers that block transparency.  A non-transparent BaseObject can only be added to this map if the layer it is on is contained
            within this layer mask.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.TransparencyView">
            <summary>
            IMapView representing transparency values for each tile.  Each location is true if the location is transparent (there are no non-transparent objects
            at that location), false otherwise.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.WalkabilityView">
            <summary>
            IMapView representing walkability values for each tile.  Each location is true if the location is walkable (there are no non-walkable objects
            at that location), false otherwise.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.FOV">
            <summary>
            Current FOV results for the map.  Calculate FOV via the Map's CalculateFOV functions.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.AStar">
            <summary>
            AStar pathfinder for the map.  Uses WalkabilityView to determine which locations can be reached.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.DistanceMeasurement">
            <summary>
            Distance measurement used for pathing and measuring distance on the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map`1.ObjectAdded">
            <summary>
            Event that is fired whenever some object is added to the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map`1.ObjectRemoved">
            <summary>
            Event that is fired whenever some object is removed from the map.
            </summary>
        </member>
        <member name="E:GoRogue.GameFramework.Map`1.ObjectMoved">
            <summary>
            Event that is fired whenever some object that is part of the map is successfully moved.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.Height">
            <summary>
            Height of the map, in grid spaces.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.Width">
            <summary>
            Width of the map, in grid spaces.
            </summary>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.Item(GoRogue.Coord)">
            <summary>
            Gets all objects at the given location, from the highest layer (layer with the highest number) down.
            </summary>
            <param name="pos">The position to retrieve objects for.</param>
            <returns>All objects at the given location, in order from highest layer to lowest layer.</returns>
        </member>
        <member name="P:GoRogue.GameFramework.Map`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets all objects at the given location, from the highest layer (layer with the highest number) down.
            </summary>
            <param name="x">X-value of the position to retrieve objects for.</param>
            <param name="y">Y-value of the position to retrieve objects for.</param>
            <returns>All objects at the given location, in order from highest layer to lowest layer.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.#ctor(System.Int32,System.Int32,System.Int32,GoRogue.Distance,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor.  Constructs terrain map as ArrayMap&lt;BaseObject&gt; with the given width/height.
            </summary>
            <param name="width">Width of the map.</param>
            <param name="height">Height of the map.</param>
            <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
            <param name="distanceMeasurement">Distance measurement to use for pathing/measuring distance on the map.</param>
            <param name="layersBlockingWalkability">Layer mask containing those layers that should be allowed to have items that block walkability.
            Defaults to all layers.</param>
            <param name="layersBlockingTransparency">Layer mask containing those layers that should be allowed to have items that block FOV.
            Defaults to all layers.</param>
            <param name="entityLayersSupportingMultipleItems">Layer mask containing those layers that should be allowed to have multiple objects at the same
            location on the same layer.  Defaults to no layers.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.#ctor(GoRogue.MapViews.ISettableMapView{`0},System.Int32,GoRogue.Distance,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Constructor.  Constructs map with the given terrain layer, determining width/height based on the width/height of that terrain layer.
            </summary>
            <param name="terrainLayer">The ISettableMapView that represents the terrain layer for this map.  It is intended that this be modified
            ONLY via the SetTerrain function -- if it is modified outside of that, the ItemAdded/Removed events are NOT guaranteed to be called!</param>
            <param name="numberOfEntityLayers">Number of non-terrain layers for the map.</param>
            <param name="distanceMeasurement">Distance measurement to use for pathing/measuring distance on the map.</param>
            <param name="layersBlockingWalkability">Layer mask containing those layers that should be allowed to have items that block walkability.
            Defaults to all layers.</param>
            <param name="layersBlockingTransparency">Layer mask containing those layers that should be allowed to have items that block FOV.
            Defaults to all layers.</param>
            <param name="entityLayersSupportingMultipleItems">Layer mask containing those layers that should be allowed to have multiple objects at the same
            location on the same layer.  Defaults to no layers.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.GetTerrain(GoRogue.Coord)">
            <summary>
            Gets the terrain object at the given location, or null if no terrain is set to that location.
            </summary>
            <param name="position">The position to get the terrain for.</param>
            <returns>The terrain at the given postion, or null if no terrain exists at that location.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.GetTerrain(System.Int32,System.Int32)">
            <summary>
            Gets the terrain object at the given location, or null if no terrain is set to that location.
            </summary>
            <param name="x">X-value of the position to get the terrain for.</param>
            <param name="y">Y-value of the position to get the terrain for.</param>
            <returns>The terrain at the given postion, or null if no terrain exists at that location.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.SetTerrain(`0)">
            <summary>
            Sets the terrain at the given objects location to the given object, overwriting any terrain already present there.
            </summary>
            <param name="terrain">Terrain to replace the current terrain with.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.AddEntity(`0)">
            <summary>
            Adds the given entity to its recorded location, removing it from the map it is currently a part of.  Returns true if the entity was added, 
            false otherwise (eg., collision detection would not allow it, etc.)
            </summary>
            <param name="entity">Entity to add.</param>
            <returns>True if the entity was successfully added to the map, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.RemoveEntity(`0)">
            <summary>
            Removes the given entity from the map, returning true if it was successfully removed, false otherwise.
            </summary>
            <param name="entity">The entity to remove from the map.</param>
            <returns>True if the entity was removed successfully, false otherwise (eg, the entity was not part of this map).</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.GetObject(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position, moving from the highest existing layer in the layer mask downward.  Layer mask defaults to all
            layers.
            </summary>
            <param name="position">Position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.GetObject(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the first object encountered at the given position, moving from the highest existing layer in the layer mask downward.  Layer mask defaults to all
            layers.
            </summary>
            <param name="x">X-value of the position to get object for.</param>
            <param name="y">Y-value of the position to get object for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>The first object encountered, moving from the highest existing layer in the layer mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.GetObjects(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position, in order from the highest existing layer in the layer mask downward.  Layer mask defaults to all layers.
            </summary>
            <param name="position">Position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position, in order from the highest existing layer in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.GetObjects(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets all objects encountered at the given position, in order from the highest existing layer in the layer mask downward.  Layer mask defaults to all layers.
            </summary>
            <param name="x">X-value of the position to get objects for.</param>
            <param name="y">Y-value of the position to get objects for.</param>
            <param name="layerMask">Layer mask for which layers can return an object.  Defaults to all layers.</param>
            <returns>All objects encountered at the given position, in order from the highest existing layer in the mask downward.</returns>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.CalculateFOV(GoRogue.Coord,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius (of shape circle), and stores the result in the FOV property.  All tiles that are in the resulting FOV
            are marked as explored.
            </summary>
            <param name="position">The center point of the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.CalculateFOV(System.Int32,System.Int32,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius (of shape circle), and stores the result in the FOV property.  All tiles that are in the resulting FOV
            are marked as explored.
            </summary>
            <param name="x">X-value of the center point for the new FOV to calculate.</param>
            <param name="y">Y-value of the center point for the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.CalculateFOV(GoRogue.Coord,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV with the given center point and radius, and stores the result in the FOV property.  All tiles that are in the resulting FOV
            are marked as explored.
            </summary>
            <param name="position">The center point of the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either Distance or Radius types (they are implicitly convertible).</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance)">
            <summary>
            Calculates FOV with the given center point and radius, and stores the result in the FOV property.  All tiles that are in the resulting FOV
            are marked as explored.
            </summary>
            <param name="x">X-value of the center point for the new FOV to calculate.</param>
            <param name="y">Y-value of the center point for the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either Distance or Radius types (they are implicitly convertible).</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.CalculateFOV(GoRogue.Coord,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius, restricted to the given angle and span, and stores the result in the FOV property.  All tiles that
            are in the resulting FOV are marked as explored.
            </summary>
            <param name="position">The center point of the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either Distance or Radius types (they are implicitly convertible).</param>
            <param name="angle">The angle in degrees the FOV cone faces.  0 degrees points right.</param>
            <param name="span">The angle in degrees specifying the full arc of the FOV cone.  span/2 degrees on either side of the given angle are included
            in the cone.</param>
        </member>
        <member name="M:GoRogue.GameFramework.Map`1.CalculateFOV(System.Int32,System.Int32,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Calculates FOV with the given center point and radius, restricted to the given angle and span, and stores the result in the FOV property.  All tiles that
            are in the resulting FOV are marked as explored.
            </summary>
            <param name="x">X-value of the center point for the new FOV to calculate.</param>
            <param name="y">Y-value of the center point for the new FOV to calculate.</param>
            <param name="radius">The radius of the FOV.  Defaults to infinite.</param>
            <param name="radiusShape">The shape of the FOV to calculate.  Can be specified as either Distance or Radius types (they are implicitly convertible).</param>
            <param name="angle">The angle in degrees the FOV cone faces.  0 degrees points right.</param>
            <param name="span">The angle in degrees specifying the full arc of the FOV cone.  span/2 degrees on either side of the given angle are included
            in the cone.</param>
        </member>
        <member name="T:GoRogue.IDGenerator">
            <summary>
            Class designed as a helper for situations where you need to generate and assign a unique
            integer to each instance of a class, eg. for a class implementing IHasID (see that interface
            documentation for usage example). One may initialize it with a starting unsigned integer, or
            0 if none is specified. Then, every time one wants to use an integer, one should call
            UseID(), and use the one it returns. It is not thread-safe on its own -- if it needs to be,
            one might consider using a lock around any UseID calls.
            </summary>
        </member>
        <member name="M:GoRogue.IDGenerator.#ctor(System.UInt32)">
            <summary>
            Constructor.
            </summary>
            <param name="startingInt">
            Unsigned integer to start at (one that will be returned first time UseID is called).
            Default 0.
            </param>
        </member>
        <member name="M:GoRogue.IDGenerator.UseID">
            <summary>
            Call every time you wish to "assign" an ID. The integer returned will never be returned
            again (each integer will be unique, per instance of this class).
            </summary>
            <returns>The ID that has been assigned.</returns>
        </member>
        <member name="T:GoRogue.IHasID">
            <summary>
            Interface for a class that has an ID, typically used for hashing purposes.  The ID should be unique or close to unique
            over all instances of the class (for efficiency). Typical implementation could be simply random-genning the ID, or for completely unique IDs 
            can involve using an IDGenerator, potentially as follows: <example>
            <code>
            class SomeClass : IHasID
            {
            private static IDGenerator generator = new IDGenerator();
            public int ID { get; private set; }
            /// public SomeClass(...)
            {
            ID = generator.UseID();
            }
            }
            </code>
            </example> A class that wishes to be able to have these IDs serialized and the state resumed
            later might have to do something more advanced than a static variable (say, a "global" array
            of generators whose states are read in from a file at the start of the game), but the
            principle would remain the same. Interface is used for SpatialMap to work correctly, and
            as well in general provides a convenient way to hash entities that implement this interface.
            </summary>
        </member>
        <member name="P:GoRogue.IHasID.ID">
            <summary>ID assigned to this entity.
            </summary>
        </member>
        <member name="T:GoRogue.IHasLayer">
            <summary>
            Interface to be implemented by objects that will be used in LayeredSpatialMap/Map classes.
            </summary>
        </member>
        <member name="P:GoRogue.IHasLayer.Layer">
            <summary>
            The layer on which the object should reside.  Higher numbers indicate layers closer to the "top".  This is assumed to remain constant
            while the object is within a data structure that uses this interface, if it is modified, that data structure will become out of sync.
            </summary>
        </member>
        <member name="T:GoRogue.IReadOnlyDisjointSet">
            <summary>
            Basic read-only representation of a Disjoint set data structure. Assumes it is holding
            integers between 0 and size - 1.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyDisjointSet.Count">
            <summary>
            Number of distinct sets.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet.Find(System.Int32)">
            <summary>
            Returns the parent of the set containing obj, performing path compression as search is completed.
            </summary>
            <param name="obj">Object to search for.</param>
            <returns>The parent of the obj given.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyDisjointSet.InSameSet(System.Int32,System.Int32)">
            <summary>
            Returns true if the two objects specified are in the same set.
            </summary>
            <param name="obj1">First object.</param>
            <param name="obj2">Second object.</param>
            <returns>True if the two objects are in the same set, false otherwise.</returns>
        </member>
        <member name="T:GoRogue.IReadOnlyFOV">
            <summary>
            Read-only interface of the FOV class.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.CurrentFOV">
            <summary>
            IEnumerable of only positions currently in FOV.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.NewlySeen">
            <summary>
            IEnumerable of positions that are in FOV as of the most current Calculate call, but were
            NOT in FOV afterthe previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.NewlyUnseen">
            <summary>
            IEnumerable of positions that are NOT in FOV as of the most current Calculate call, but
            WERE in FOV after the previous time Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyFOV.BooleanFOV">
            <summary>
            A view of the FOV results in boolean form, where true indicates a location is in FOV, and false indicates it is not.
            </summary>
        </member>
        <member name="T:GoRogue.IReadOnlyLayeredSpatialMap`1">
            <summary>
            Read-only interface for LayeredSpatialMap -- useful for exposing LayeredSpatialMap instances as read-only properties.
            </summary>
            <typeparam name="T">Type of element stored in the layered spatial map -- must implement IHasLayer.</typeparam>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.StartingLayer">
            <summary>
            Starting index for layers included in this structure.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.Layers">
            <summary>
            Gets read-only spatial maps representing each layer.  To access a specific layer, instead use GetLayer.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.LayerMasker">
            <summary>
            Object that helps get layer masks as they pertain to this LayeredSpatialMap
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyLayeredSpatialMap`1.NumberOfLayers">
            <summary>
            Gets the number of layers represented.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.AsReadOnly">
            <summary>
            Returns a read-only reference to the data structure. Convenient for "safely" exposing the
            structure as a property.
            </summary>
            <returns>The current data structure, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetItems(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the item(s) associated with the given position that reside on any layer included in the given layer mask.  Returns
            nothing if there is nothing at that position on a layer included in the given layer mask.
            </summary>
            <param name="position">The position to return the item(s) for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check. Defaults to all layers.</param>
            <returns>
            The item(s) at the given position that reside on a layer included in the layer mask if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetItems(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the item(s) associated with the given position that reside on any layer included in the given layer mask.  Returns
            nothing if there is nothing at that position on a layer included in the given layer mask.
            </summary>
            <param name="x">X-value of the position to return the item(s) for.</param>
            <param name="y">Y-value of the position to return the item(s) for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check. Defaults to all layers.</param>
            <returns>
            The item(s) at the given position that reside on a layer included in the layer mask if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.Contains(GoRogue.Coord,System.UInt32)">
            <summary>
            Returns whether or not there is an item in the data structure at the given position that is on a layer included in the given layer mask.  Defaults
            to searching on all layers.
            </summary>
            <param name="position">The position to check for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check.  Defaults to all layers.</param>
            <returns>True if there is some item at the given position on a layer included in the given layer mask, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.Contains(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Returns whether or not there is an item in the data structure at the given position, that is on a layer included in the given layer mask.
            </summary>
            <param name="x">X-value of the position to check for.</param>
            <param name="y">Y-value of the position to check for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check. Defaults to all layers.</param>
            <returns>True if there is some item at the given position on a layer included in the given layer mask, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetLayer(System.Int32)">
            <summary>
            Gets a read-only spatial map representing the layer given.
            </summary>
            <param name="layer">The layer to retrieve.</param>
            <returns>The IReadOnlySpatialMap that represents the given layer.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlyLayeredSpatialMap`1.GetLayers(System.UInt32)">
            <summary>
            Returns read-only spatial maps that represent each layer included in the given layer mask.  Defaults to all layers.
            </summary>
            <param name="layerMask">Layer mask indicating which layers to return.  Defaults to all layers.</param>
            <returns></returns>
        </member>
        <member name="T:GoRogue.LayerMasker">
            <summary>
            Allows convenient interpretation and creation of layer masks (bit-masks) mask layers represented by
            integers [0-NumberOfLayers - 1].
            </summary>
        </member>
        <member name="F:GoRogue.LayerMasker.DEFAULT">
            <summary>
            Default layer masker, that excludes no possible layers from its results.
            </summary>
        </member>
        <member name="P:GoRogue.LayerMasker.NumberOfLayers">
            <summary>
            Maximum number of layers supported by this layer masker.  Functions enforce this limit, and will not consider
            layers outside the range [0, NumberOfLayers - 1]
            </summary>
        </member>
        <member name="F:GoRogue.LayerMasker.ALL_LAYERS">
            <summary>
            Layer-mask representing all layers.
            </summary>
        </member>
        <member name="F:GoRogue.LayerMasker.NO_LAYERS">
            <summary>
            Layer mask representing no layers.
            </summary>
        </member>
        <member name="M:GoRogue.LayerMasker.#ctor(System.Int32)">
            <summary>
            Constructor.  Takes the number of layers allowed, which must be more than 0 and less than or equal to 32.
            </summary>
            <param name="numberOfLayers">The number of layers supported by this layer mask generator.</param>
        </member>
        <member name="M:GoRogue.LayerMasker.Mask(System.Int32[])">
            <summary>
            Gets a layer mask including exactly the given layer indices.  Any layer given outside the maximum number of layers is ignored,
            and will not be added to the resulting mask.
            </summary>
            <param name="layers">One or more layers to include in generated layer mask.</param>
            <returns>A layer mask including exactly those layers in the input that were within the supported number of layers.</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.Mask(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Gets a layer mask including exactly the given layer indices.  Any layer given outside the maximum number of layers is ignored,
            and will not be added to the resulting mask.
            </summary>
            <param name="layers">Layers to include in generated layer mask.</param>
            <returns>A layer mask including exactly those layers in the input that were within the supported number of layers.</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.AddLayers(System.UInt32,System.Int32[])">
            <summary>
            Adds the given layers to the given layer mask, provided those layers are within the supported number of layers.  Any layer
            outside of this range will not be added.
            </summary>
            <param name="mask">The mask to add the layers to.</param>
            <param name="layers">Layers to include in the resulting layer mask.</param>
            <returns>A layer mask including any original layers that were in the given mask (regardless of whether they were within the supported number of
            layers), as well as the new layers provided (provided they are within the supported number of layers).</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.AddLayers(System.UInt32,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Adds the given layers to the given layer mask, provided those layers are within the supported number of layers.  Any layer
            outside of this range will not be added.
            </summary>
            <param name="mask">The mask to add the layers to.</param>
            <param name="layers">Layers to include in the resulting layer mask.</param>
            <returns>A layer mask including any original layers that were in the given mask (regardless of whether they were within the supported number of
            layers), as well as the new layers provided (provided they are within the supported number of layers).</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.MaskAllBelow(System.Int32)">
            <summary>
            Generates and returns a layer mask including the given layer and any layer below (less than) it.  Layers not in the supported number
            of layers will be ignored, and will not be added to the resulting layer mask.
            </summary>
            <param name="layer">Layer to start the mask at.</param>
            <returns>A layer mask including the specified layer and all layers below it, provided those layers fall within the supported
            number of layers.</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.MaskAllAbove(System.Int32)">
            <summary>
            Generates and returns a layer mask including the given layer and any layer above (greater than) it.  Layers not in the supported number
            of layers will be ignored, and will not be added to the resulting layer mask.
            </summary>
            <param name="layer">Layer to start the mask at.</param>
            <returns>A layer mask including the specified layer and all layers above it, provided those layers fall within the supported
            number of layers.</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.HasLayer(System.UInt32,System.Int32)">
            <summary>
            Returns whether or not a layer is contained within the given layer mask.  Returns false if the layer given is outside the supported number
            of layers.
            </summary>
            <param name="mask">Layer mask to check.</param>
            <param name="layer">Layer to check for.</param>
            <returns>True if the given layer is present in the given layer mask, false if it is not or the layer is outside the supported
            number of layers for this LayerMasker.</returns>
        </member>
        <member name="M:GoRogue.LayerMasker.Layers(System.UInt32)">
            <summary>
            Returns an IEnumerable of all layers contained within the given layer mask (that fall within the supported number of layers).
            </summary>
            <param name="mask">Layer mask to return layers for.</param>
            <returns>All layers contained within the given layer mask that fall within the supported number of layers for this LayerMasker.</returns>
        </member>
        <member name="T:GoRogue.IReadOnlyRadiusAreaProvider">
            <summary>
            Read-only interface of a RadiusAreaProvider.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.Bounds">
            <summary>
            The bounds to constrain the returned Coords to. Set to Rectangle.EMPTY to indicate that
            there are no bounds.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.Center">
            <summary>
            The center point of the radius.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlyRadiusAreaProvider.Radius">
            <summary>
            The length of the radius, eg. the number of tiles from the center point (as defined by
            the distance calculation/radius shape given) to which the radius extends.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlyRadiusAreaProvider.CalculatePositions">
            <summary>
            Calculates the new radius, and returns an IEnumerable of all unique Coords within that
            radius and bounds specified (as applicable). See RadiusAreaProvider class description for
            details on the ordering. Safe to expose in read-only class, since it does not modify the
            public interface of the RadiusAreaProvider.
            </summary>
            <returns>Enumerable of all unique Coords within the radius and bounds specified.</returns>
        </member>
        <member name="T:GoRogue.IReadOnlySpatialMap`1">
            <summary>
            See ISpatialMap documentation. Similar in principle to the C# standard
            IReadOnlyList/IReadOnlyCollection interface. Simply exposes only those functions of the
            ISpatialMap interface that do not allow direct modification of the data (eg.
            adding/moving/removing items). This can allow for direct exposure of an ISpatialMap as a
            property of type IReadOnlySpatialMap, without allowing such an exposure to break data
            encapsulation principles of something like a game map.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlySpatialMap`1.Count">
            <summary>
            The number of items in the data structure.
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlySpatialMap`1.Items">
            <summary>
            Enumerable of the items stored in the data structure: for use to iterate over all items,
            eg: <example>
            <code>
            foreach (var item in mySpatialMap.Items)
            // Do stuff
            </code>
            </example>
            </summary>
        </member>
        <member name="P:GoRogue.IReadOnlySpatialMap`1.Positions">
            <summary>
            Enumerable of all positions that contain items. Likely this won't be used as much, since
            most objects that are contained in a spatial map implementation will record their
            position as a member, however in case that is not the case for a particular use, or just
            as a convenience if you only care about the coordinates, this is provided.
            </summary>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.AsReadOnly">
            <summary>
            Returns a read-only reference to the data structure. Convenient for "safely" exposing the
            structure as a property.
            </summary>
            <returns>The current data structure, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.Contains(`0)">
            <summary>
            Returns whether or not the data structure contains the given item.
            </summary>
            <param name="item">The item to check for.</param>
            <returns>True if the given item is in the data structure, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.Contains(GoRogue.Coord)">
            <summary>
            Returns if there is an item in the data structure at the given position or not.
            </summary>
            <param name="position">The position to check for.</param>
            <returns>True if there is some item at the given position, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.Contains(System.Int32,System.Int32)">
            <summary>
            Returns if there is an item in the data structure at the given position or not.
            </summary>
            <param name="x">The x-value of the position to check for.</param>
            <param name="y">The y-value of the position to check for.</param>
            <returns>True if there is some item at the given position, false if not.</returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.GetItems(GoRogue.Coord)">
            <summary>
            Gets the item(s) associated with the given position if there are any items, or returns
            nothing if there is nothing at that position.
            </summary>
            <param name="position">The position to return the item(s) for.</param>
            <returns>
            The item(s) at the given position if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.GetItems(System.Int32,System.Int32)">
            <summary>
            Gets the item(s) associated with the given position if there are any items, or returns
            nothing if there is nothing at that position.
            </summary>
            <param name="x">The x-value of the position to return the item(s) for.</param>
            <param name="y">The y-value of the position to return the item(s) for.</param>
            <returns>
            The item(s) at the given position if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.IReadOnlySpatialMap`1.GetPosition(`0)">
            <summary>
            Gets the position associated with the item in the data structure, or null if that item is
            not found.
            </summary>
            <param name="item">The item to get the position for.</param>
            <returns>
            The position associated with the given item, if it exists in the data structure, or null
            if the item does not exist.
            </returns>
        </member>
        <member name="T:GoRogue.ISpatialTuple`1">
            <summary>
            Interface specifying return type for item-location pairs in a spatial map implementation.
            </summary>
            <typeparam name="T">Type of the item associated with locations.</typeparam>
        </member>
        <member name="P:GoRogue.ISpatialTuple`1.Item">
            <summary>
            The item associated with this pair.
            </summary>
        </member>
        <member name="P:GoRogue.ISpatialTuple`1.Position">
            <summary>
            The position associated with this pair.
            </summary>
        </member>
        <member name="T:GoRogue.ISpatialMap`1">
            <summary>
            General interface for a data structure that records objects on a map.
            </summary>
            <remarks>
            Different implementations of this interface are provided by to the library, each
            providing somewhat different implementations and constraints, however generally they provide more
            efficient implementations of many of these operations than the standard "list of monsters"
            that is often used in roguelike map design.
            </remarks>
            <typeparam name="T">The type of object that will be contained by the data structure.</typeparam>
        </member>
        <member name="E:GoRogue.ISpatialMap`1.ItemAdded">
            <summary>
            Fired directly after an item has been added to the data structure.
            </summary>
        </member>
        <member name="E:GoRogue.ISpatialMap`1.ItemMoved">
            <summary>
            Fired directly after an item in the data structure has been moved.
            </summary>
        </member>
        <member name="E:GoRogue.ISpatialMap`1.ItemRemoved">
            <summary>
            Fired directly after an item has been removed from the data structure.
            </summary>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position, and returns true if the item was successfully
            added. If the item could not be added, returns false.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="position">Position to add item to.</param>
            <returns>True if item was successfully added, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, and returns true if the item was successfully
            added. If the item could not be added, returns false.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="x">X-value of the position to add item to.</param>
            <param name="y">Y-value of the position to add item to.</param>
            <returns>True if item was successfully added, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Clear">
            <summary>
            Clears all items out of the data structure.
            </summary>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Moves the given item from its current location to the specified one. Returns true if the
            item was successfully moved, false otherwise.
            </summary>
            <param name="item">Item to move</param>
            <param name="target">Location to move item to.</param>
            <returns>True if item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Moves the given item from its current location to the specified one. Returns true if the
            item was successfully moved, false otherwise.
            </summary>
            <param name="item">Item to move</param>
            <param name="targetX">X-value of the location to move item to.</param>
            <param name="targetY">Y-value of the location to move item to.</param>
            <returns>True if item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves any items at the specified location to the target one. Returns any items that were moved.
            </summary>
            <param name="current">Location to move items from.</param>
            <param name="target">Location to move items to.</param>
            <returns>Any items that were moved, nothing if no items were moved.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves any items at the specified location to the target one. Returns any items that were moved.
            </summary>
            <param name="currentX">X-value of the location to move items from.</param>
            <param name="currentY">Y-value of the location to move items from.</param>
            <param name="targetX">X-value of the location to move items to.</param>
            <param name="targetY">Y-value of the location to move items to.</param>
            <returns>Any items that were moved, nothing if no items were moved.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Remove(`0)">
            <summary>
            Removes the given item from the data structure, returning true if the item was removed or
            false otherwise.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if item was removed, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Remove(GoRogue.Coord)">
            <summary>
            Removes any items at the specified location from the data structure. Returns any items
            that were removed.
            </summary>
            <param name="position">Position to remove items from.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.ISpatialMap`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes any items at the specified location from the data structure. Returns any items
            that were removed.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="T:GoRogue.ItemEventArgs`1">
            <summary>
            Event args for spatial map events pertaining to an item (item added, item removed, etc.)
            </summary>
            <typeparam name="T">Type of item.</typeparam>
        </member>
        <member name="M:GoRogue.ItemEventArgs`1.#ctor(`0,GoRogue.Coord)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="position">Current position of the item.</param>
        </member>
        <member name="M:GoRogue.ItemEventArgs`1.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="x">X-value of the current position of the item.</param>
            <param name="y">Y-value of the current position of the item.</param>
        </member>
        <member name="P:GoRogue.ItemEventArgs`1.Item">
            <summary>
            Item being represented.
            </summary>
        </member>
        <member name="P:GoRogue.ItemEventArgs`1.Position">
            <summary>
            Current position of that item at time of event.
            </summary>
        </member>
        <member name="T:GoRogue.ItemMovedEventArgs`1">
            <summary>
            Event args for SpatialMap's ItemMoved event.
            </summary>
            <typeparam name="T">Type of item being stored.</typeparam>
        </member>
        <member name="M:GoRogue.ItemMovedEventArgs`1.#ctor(`0,GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="oldPosition">Position of item before it was moved.</param>
            <param name="newPosition">Position of item after it has been moved.</param>
        </member>
        <member name="M:GoRogue.ItemMovedEventArgs`1.#ctor(`0,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="item">Item being represented.</param>
            <param name="oldPositionX">X-value of the position of item before it was moved.</param>
            <param name="oldPositionY">Y-value of the position of item before it was moved.</param>
            <param name="newPositionX">X-value of the position of item after it has been moved.</param>
            <param name="newPositionY">Y-value of the position of item after it has been moved.</param>
        </member>
        <member name="P:GoRogue.ItemMovedEventArgs`1.Item">
            <summary>
            Item being represented.
            </summary>
        </member>
        <member name="P:GoRogue.ItemMovedEventArgs`1.NewPosition">
            <summary>
            Position of item after it has been moved.
            </summary>
        </member>
        <member name="P:GoRogue.ItemMovedEventArgs`1.OldPosition">
            <summary>
            Position of item before it was moved.
            </summary>
        </member>
        <member name="T:GoRogue.IDComparer`1">
            <summary>
            Class intended for comparing/hashing objects that implement IHasID.  Type T must be a reference type.
            </summary>
            <typeparam name="T">Type of object being compared.  Type T must be a reference type that implements IHasID.</typeparam>
        </member>
        <member name="M:GoRogue.IDComparer`1.Equals(`0,`0)">
            <summary>
            Equality comparison.  Performs comparison via the object's ReferenceEquals function.
            </summary>
            <param name="x">First object to compare.</param>
            <param name="y">Second object to compare.</param>
            <returns>True if the objects are considered equal, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.IDComparer`1.GetHashCode(`0)">
            <summary>
            Generates a hash based on the object's ID.GetHashCode() function.
            </summary>
            <param name="obj">Object to generate the hash for.</param>
            <returns>The hash of the object, based on its ID.</returns>
        </member>
        <member name="T:GoRogue.LayeredSpatialMap`1">
            <summary>
            ISpatialMap implementation that can be used to efficiently represent "layers" of objects, with each layer represented as a SpatialMap.
            It uses layer masking (bit-masking per layer) to allow functions to operate on specific layers.  Items must implement IHasID and IHasLayer,
            be a reference type, and their Layer value MUST NOT change while they are in the data structure.
            </summary>
            <remarks>
            This class is desinged to wrap a bunch of ISpatialMap instances together.  At creation, whether or not each layer supports
            multiple items at the same location is specified via a layer mask..  One spatial map represents one layer of a map (items, monsters, etc).
            This class provides read-only access to each layer, as well as functions to add/remove/move items, do item grabbing based on layers, etc.
            Will not allow the same item to be added to multiple layers.
            </remarks>
            <typeparam name="T">Type of items in the layers.  Type T must implement IHasID and IHasLayer, must be a reference type, and its IHasLayer.Layer value MUST NOT
            change while the item is in the LayeredSpatialMap.</typeparam>
        </member>
        <member name="M:GoRogue.LayeredSpatialMap`1.#ctor(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Constructor.  Takes number of layers to include, as well as a starting layer index (defaulting to 0) and a layer mask indicating which
            layers support multiple items at a single position (defaulting to no layers).
            </summary>
            <remarks>
            This class allows you to specify the starting index in order to make it easy to combine with other structures in a map which may represent other
            layers.  For example, if a startingLayer of 0 is specified, layers in the spatialMap will have number [0-numberOfLayers - 1].  If 1 is specified,
            layers will have numbers [1-numberOfLayers], and anything to do with layer 0 will be ignored.  If a layer-mask that includes layers 0, 2, and 3
            is passed to a function, for example, only layers 2 and 3 are considered (since they are the only ones that would be included in the LayeredSpatialMap.
            </remarks>
            <param name="numberOfLayers">Number of layers to include.</param>
            <param name="startingLayer">Index to use for the first layer.</param>
            <param name="layersSupportingMultipleItems">A layer mask indicating which layers should support multiple items residing at the same location on that
            layer.  Defaults to no layers.</param>
        </member>
        <member name="T:GoRogue.AdvancedLayeredSpatialMap`1">
            <summary>
            Advanced version of LayeredSpatialMap that allows for use of a custom IEqualityComparer for hashing and comparison of type T.
            May be useful for cases where one does not want to implement IHasID, or if you need to use a value type in a LayeredSpatialMap.  For simple
            cases, it is recommended to use LayeredSpatialMap instead.
            </summary>
            <remarks>
            Be mindful of the efficiency of your hashing function specified in the IEqualityComparer -- it will in large part determine the performance of
            AdvancedLayeredSpatialMap!
            </remarks>
            <typeparam name="T">Type of items in the layers.  Type T must implement IHasLayer, and its IHasLayer.Layer value MUST NOT
            change while the item is in the AdvancedLayeredSpatialMap.</typeparam>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.StartingLayer">
            <summary>
            Starting index for layers included in theis LayeredSpatialMap.  Specified at construction.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.LayerMasker">
            <summary>
            Object that helps get layer masks as they pertain to this LayeredSpatialMap
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Layers">
            <summary>
            Gets read-only spatial maps representing each layer.  To access a specific layer, instead use GetLayer.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedLayeredSpatialMap`1.ItemAdded">
            <summary>
            Fires whenever an item is added to any layer.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedLayeredSpatialMap`1.ItemMoved">
            <summary>
            Fires whenever an item is moved on any layer.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedLayeredSpatialMap`1.ItemRemoved">
            <summary>
            Fires whenever an item is removed from any layer.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.NumberOfLayers">
            <summary>
            Gets the number of layers represented.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Count">
            <summary>
            Gets the number of entities on all layers.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Items">
            <summary>
            Gets all the items on all layers.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedLayeredSpatialMap`1.Positions">
            <summary>
            Gets all positions that have items for each layer.  No positions are duplicated if multiple layers have an item at a position.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32,System.Int32,System.UInt32)">
            <summary>
            Constructor.  Takes a comparator to use, number of layers to include, as well as a starting layer index (defaulting to 0) and a layer mask indicating which
            layers support multiple items at a single position (defaulting to no layers).
            </summary>
            <remarks>
            This class allows you to specify the starting index in order to make it easy to combine with other structures in a map which may represent other
            layers.  For example, if a startingLayer of 0 is specified, layers in the spatialMap will have number [0-numberOfLayers - 1].  If 1 is specified,
            layers will have numbers [1-numberOfLayers], and anything to do with layer 0 will be ignored.  If a layer-mask that includes layers 0, 2, and 3
            is passed to a function, for example, only layers 2 and 3 are considered (since they are the only ones that would be included in the LayeredSpatialMap.
            </remarks>
            <param name="comparer">Equality comparer to use for comparison and hashing of type T.  Be mindful of the efficiency
            of this instances GetHashCode function, as it will determine the efficiency of many AdvancedLayeredSpatialMap functions.</param>
            <param name="numberOfLayers">Number of layers to include.</param>
            <param name="startingLayer">Index to use for the first layer.</param>
            <param name="layersSupportingMultipleItems">A layer mask indicating which layers should support multiple items residing at the same location on that
            layer.  Defaults to no layers.</param>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetLayer(System.Int32)">
            <summary>
            Gets a read-only spatial map representing the layer given.
            </summary>
            <param name="layer">The layer to retrieve.</param>
            <returns>The IReadOnlySpatialMap that represents the given layer.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetLayers(System.UInt32)">
            <summary>
            Returns read-only spatial maps that represent each layer included in the given layer mask.  Defaults to all layers.
            </summary>
            <param name="layerMask">Layer mask indicating which layers to return.  Defaults to all layers.</param>
            <returns></returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position.  Item is automatically added to correct layer.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="position">Position to add item at.</param>
            <returns>True if the item was successfully added -- false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, or returns false if the item cannot be added.  Item is automatically added to correct layer.
            </summary>
            <param name="newItem">Item to add.</param>
            <param name="x">X-value of position to add item at.</param>
            <param name="y">Y-value of position to add item at.</param>
            <returns>True if the item was successfully added, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Clear">
            <summary>
            Clears all items from all layers.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Moves the given item to the given position, or returns false if the item cannot be moved.
            </summary>
            <param name="item">Item to move.</param>
            <param name="target">Position to move the given item to.</param>
            <returns>True if the item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Moves the given item to the given position, or returns false if the item cannot be moved.
            </summary>
            <param name="item">Item to move.</param>
            <param name="targetX">X-value of position to move the given item to.</param>
            <param name="targetY">Y-value of position to move the given item to.</param>
            <returns>True if the item was successfully moved, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves all items on all layers at the given position to the new position.
            </summary>
            <param name="current">Position to move items from.</param>
            <param name="target">Position to move items to</param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord,System.UInt32)">
            <summary>
            Moves all items at the given position, that are on any layer specified by the given layer mask, to the new position.
            If no layer mask is specified, defaults to all layers.
            </summary>
            <param name="current">Position to move all items from.</param>
            <param name="target">Position to move all items to.</param>
            <param name="layerMask">Layer mask specifying which layers to search for items on. Defaults to all layers.</param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves all items on all layers at the given position to the new position.
            </summary>
            <param name="currentX">X-value of the position to move items from.</param>
            <param name="currentY">Y-value of the position to move items from.</param>
            <param name="targetX">X-value of the position to move items to.</param>
            <param name="targetY">Y-value of the position to move itesm from.</param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            Moves all items at the given position, that are on any layer specified by the given layer mask, to the new position.
            If no layer mask is specified, defaults to all layers.
            </summary>
            <param name="currentX">X-value of the position to move items from.</param>
            <param name="currentY">Y-value of the position to move items from.</param>
            <param name="targetX">X-value of the position to move items to.</param>
            <param name="targetY">Y-value of the position to move itesm from.</param>
            <param name="layerMask">Layer mask specifying which layers to search for items on.  Defaults to all layers.</param>
            <returns>All items moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Remove(`0)">
            <summary>
            Removes the given item from the LayerdSpatialMap.  Returns false if the item did not exist.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if the item was removed, false otherwise (eg. the item did not exist)</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Remove(GoRogue.Coord)">
            <summary>
            Removes all items at the specified location on all layers from the data structure. Returns any items
            that were removed.
            </summary>
            <param name="position">Position to remove items from.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Remove(GoRogue.Coord,System.UInt32)">
            <summary>
            Removes all items at the specified location that are on any layer included in the given layer mask from the data structure. Returns any items
            that were removed.  Defaults to all layers.
            </summary>
            <param name="position">Position to remove items from.</param>
            <param name="layerMask">The layer mask indicating which layers to search for items.  Defaults to all layers.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#ISpatialMap{T}#Remove(System.Int32,System.Int32)">
            <summary>
            Removes all items at the specified location on all layers from the data structure. Returns any items
            that were removed.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Remove(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Removes all items at the specified location that are on any layer included in the given layer mask from the data structure. Returns any items
            that were removed.  Defaults to all layers.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <param name="layerMask">The layer mask indicating which layers to search for items.  Defaults to all layers.</param>
            <returns>Any items that were removed, or nothing if no items were removed.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#AsReadOnly">
            <summary>
            Returns a read-only reference to the data structure as an ISpatialMap.
            </summary>
            <returns>The current data structure, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.AsReadOnly">
            <summary>
            Returns a read-only reference to the data structure. Convenient for "safely" exposing the
            structure as a property.
            </summary>
            <returns>The current data structure, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Contains(`0)">
            <summary>
            Returns whether or not the data structure contains the given item.
            </summary>
            <param name="item">The item to check for.</param>
            <returns>True if the given item is in the data structure, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#Contains(GoRogue.Coord)">
            <summary>
            Returns if there is an item in the data structure at the given position (on any layer) or not.
            </summary>
            <param name="position">The position to check for.</param>
            <returns>True if there is some item at the given position on some layer, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Contains(GoRogue.Coord,System.UInt32)">
            <summary>
            Returns whether or not there is an item in the data structure at the given position that is on a layer included in the given layer mask.  Defaults
            to searching on all layers.
            </summary>
            <param name="position">The position to check for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check.  Defaults to all layers.</param>
            <returns>True if there is some item at the given position on a layer included in the given layer mask, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#Contains(System.Int32,System.Int32)">
            <summary>
            Returns if there is an item in the data structure at the given position (on any layer) or not.
            </summary>
            <param name="x">X-value of the position to check for.</param>
            <param name="y">Y-value of the position to check for.</param>
            <returns>True if there is some item at the given position on some layer, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.Contains(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Returns whether or not there is an item in the data structure at the given position, that is on a layer included in the given layer mask.
            </summary>
            <param name="x">X-value of the position to check for.</param>
            <param name="y">Y-value of the position to check for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check. Defaults to all layers.</param>
            <returns>True if there is some item at the given position on a layer included in the given layer mask, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#GetItems(GoRogue.Coord)">
            <summary>
            Gets the item(s) associated with the given position (from all layers) if there are any items, or returns
            nothing if there is nothing at that position.
            </summary>
            <param name="position">The position to return the item(s) for.</param>
            <returns>
            The item(s) at the given position if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetItems(GoRogue.Coord,System.UInt32)">
            <summary>
            Gets the item(s) associated with the given position that reside on any layer included in the given layer mask.  Returns
            nothing if there is nothing at that position on a layer included in the given layer mask.
            </summary>
            <param name="position">The position to return the item(s) for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check. Defaults to all layers.</param>
            <returns>
            The item(s) at the given position that reside on a layer included in the layer mask if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GoRogue#IReadOnlySpatialMap{T}#GetItems(System.Int32,System.Int32)">
            <summary>
            Gets the item(s) associated with the given position (from all layers) if there are any items, or returns
            nothing if there is nothing at that position.
            </summary>
            <param name="x">X-value of the position to return the item(s) for.</param>
            <param name="y">Y-value of the position to return the item(s) for.</param>
            <returns>
            The item(s) at the given position if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetItems(System.Int32,System.Int32,System.UInt32)">
            <summary>
            Gets the item(s) associated with the given position that reside on any layer included in the given layer mask.  Returns
            nothing if there is nothing at that position on a layer included in the given layer mask.
            </summary>
            <param name="x">X-value of the position to return the item(s) for.</param>
            <param name="y">Y-value of the position to return the item(s) for.</param>
            <param name="layerMask">Layer mask that indicates which layers to check. Defaults to all layers.</param>
            <returns>
            The item(s) at the given position that reside on a layer included in the layer mask if there are any items, or nothing if there is nothing
            at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetPosition(`0)">
            <summary>
            Gets the position associated with the item in the data structure, or null if that item is
            not found.
            </summary>
            <param name="item">The item to get the position for.</param>
            <returns>
            The position associated with the given item, if it exists in the data structure, or null
            if the item does not exist.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.GetEnumerator">
            <summary>
            Used by foreach loop, so that the class will give ISpatialTuple objects when used in a
            foreach loop. Generally should never be called explicitly.
            </summary>
            <returns>An enumerator for the SpatialMap</returns>
        </member>
        <member name="M:GoRogue.AdvancedLayeredSpatialMap`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Generic iterator used internally by foreach loops.
            </summary>
            <returns>Enumerator to ISpatialTuple instances.</returns>
        </member>
        <member name="T:GoRogue.Lines">
            <summary>
            Provides implementations of various (line-drawing) algorithms for generating points closest
            to a line between two points on a grid.
            </summary>
        </member>
        <member name="T:GoRogue.Lines.Algorithm">
            <summary>
            Various supported line-drawing algorithms.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.BRESENHAM">
            <summary>
            Bresenham's line algorithm.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.BRESENHAM_ORDERED">
            <summary>
            Bresenham's line algorithm, with the points guaranteed to be in start to finish
            order. This may be significantly slower than BRESENHAM, so if you really need
            ordering, consider DDA instead, as it is both faster than Bresenham's and implicitly ordered
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.DDA">
            <summary>
            DDA line algorithm -- effectively an optimized algorithm for producing Brensham-like
            lines. There may be slight differences in appearance when compared to lines created
            with Bresenham's, however this algorithm may also be measurably faster. Based on the
            algorithm here:
            https://hbfs.wordpress.com/2009/07/28/faster-than-bresenhams-algorithm/, as well as
            the Java library Squidlib's implementation.
            </summary>
        </member>
        <member name="F:GoRogue.Lines.Algorithm.ORTHO">
            <summary>
            Line algorithm that takes only orthoganal steps (each grid location on the line
            returned is within one cardinal direction of the previous one). Potentially useful
            for LOS in games that use MANHATTAN distance. Based on the algorithm here: http://www.redblobgames.com/grids/line-drawing.html#stepping
            </summary>
        </member>
        <member name="M:GoRogue.Lines.Get(GoRogue.Coord,GoRogue.Coord,GoRogue.Lines.Algorithm)">
            <summary>
            Returns an IEnumerable of every point, in order, closest to a line between the two points
            specified, using the line drawing algorithm given. The start and end points will be included.
            </summary>
            <param name="start">The start point of the line.</param>
            <param name="end">The end point of the line.</param>
            <param name="type">The line-drawing algorithm to use to generate the line.</param>
            <returns>
            An IEnumerable of every point, in order, closest to a line between the two points
            specified (according to the algorithm given).
            </returns>
        </member>
        <member name="M:GoRogue.Lines.Get(System.Int32,System.Int32,System.Int32,System.Int32,GoRogue.Lines.Algorithm)">
            <summary>
            Returns an IEnumerable of every point, in order, closest to a line between the two points
            specified, using the line drawing algorithm given. The start and end points will be included.
            </summary>
            <param name="startX">X-coordinate of the starting point of the line.</param>
            <param name="startY">Y-coordinate of the starting point of the line.</param>
            <param name="endX">X-coordinate of the ending point of the line.</param>
            ///
            <param name="endY">Y-coordinate of the ending point of the line.</param>
            <param name="type">The line-drawing algorithm to use to generate the line.</param>
            <returns>
            An IEnumerable of every point, in order, closest to a line between the two points
            specified (according to the algorithm given).
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.CenterBoundsConnectionPointSelector">
            <summary>
            Selects the center points of the bounding boxes of each map area. On concave map areas,
            because the center point of the bounding box is not actually guaranteed to be among the
            MapArea's walkable tiles, connecting these two points is not guaranteed to actually connect
            the entirety of the two areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.CenterBoundsConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Selects and returns a the center point of the bounding rectangle for each map area's
            positions list.
            </summary>
            <param name="area1">First map area to connect.</param>
            <param name="area2">First map area to connect.</param>
            <returns></returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.ClosestMapAreaConnector">
            <summary>
            Implements a connection algorithm that connects all unique map areas in the given map by
            connecting each area with the one closest to it.
            </summary>
            <remarks>
            The algorithm functions by first finding all unique areas in the map given by using
            MapAreaFinder.MapAreas. Then, we iterate through each area, find the closest area that is not
            already conencted to the current area, and create a tunnel between the two. Distance between
            to areas is measured as the distance between the center point of the bounding boxes of those
            areas. /// Points to connect two areas, as well as method used to create a tunnel between
            those two points, are selected via specified parameters.
            </remarks>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ClosestMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Distance,GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator)">
            <summary>
            Connects the map given using the algorithm described in the class description.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="distanceCalc">The distance calculation that defines distance/neighbors.</param>
            <param name="areaConnector">
            The area connection strategy to use. Not all methods function on maps with concave areas
            -- see respective class documentation for details.
            </param>
            ///
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified, DirectLineTunnelCreator with
            the distance calculation specified is used.
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator">
            <summary>
            Implements a tunnel creation algorithm that sets as walkable a direct line between the two
            points. In the case that MAHNATTAN distance is being used, the line is calculated via the
            Coord.CardinalPositionOnLine function. Otherwise, the line is calculated using
            Coord.PositionsOnLine (brensham's).
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator.#ctor(GoRogue.AdjacencyRule)">
            <summary>
            Constructor. Takes the distance calculation to use, which determines whether brensham's
            or CardinalPositionOnLine is used to create the tunnel.
            </summary>
            <param name="adjacencyRule">
            Method of adjacency to respect when creating tunnels. Cannot be diagonal.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Implements the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="start">Start coordinate of the tunnel.</param>
            <param name="end">End coordinate of the tunnel.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.DirectLineTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="startX">X-value of the start position of the tunnel.</param>
            <param name="startY">Y-value of the start position of the tunnel.</param>
            <param name="endX">X-value of the end position of the tunnel.</param>
            <param name="endY">Y-value of the end position of the tunnel.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator">
            <summary>
            Implements a tunnel creation algorithm that creates a tunnel that performs all needed
            vertical movement before horizontal movement, or vice versa (depending on rng).
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator.#ctor(Troschuetz.Random.IGenerator)">
            <summary>
            Constructor. Takes rng to use -- if null is specified, the default RNG is used.
            </summary>
            <param name="rng">Rng to use -- if null is specified, the default RNG is used.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Implemnets the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="start">Start coordinate of the tunnel.</param>
            <param name="end">End coordinate of the tunnel.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.HorizontalVerticalTunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel as specified in the class description.
            </summary>
            <param name="map">The map to create the tunnel on.</param>
            <param name="startX">X-value of the start position of the tunnel.</param>
            <param name="startY">Y-value of the start position of the tunnel.</param>
            <param name="endX">X-value of the end position of the tunnel.</param>
            <param name="endY">Y-value of the end position of the tunnel.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector">
            <summary>
            Interface for implementing an algorithm for selecting the Coords to connect in order to
            connect two given map areas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Implements the algorithm. Returns a tuple of two Coords -- the first Coord is the
            position in area1 to use, the second Coord is the position in area2 to use.
            </summary>
            <param name="area1">First MapArea to connect.</param>
            <param name="area2">Second MapArea to connect.</param>
            <returns>
            A tuple containing the coordinates from each MapArea to connect -- the first item in the
            tuple is the Coord in area1, the second is the Coord in area2.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.ITunnelCreator">
            <summary>
            Interface for implementing an algorithm for creating a tunnel between two positions on a
            walkability map.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ITunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Implements the algorithm, creating the tunnel between the two points (ensuring there is a
            path of positions set to true between those two points).
            </summary>
            <param name="map">Map to create the tunnel on.</param>
            <param name="start">Start position to connect.</param>
            <param name="end">End position to connect.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.ITunnelCreator.CreateTunnel(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Implements the algorithm, creating the tunnel between the two points (ensuring there is a
            path of positions set to true between those two points.
            </summary>
            <param name="map">Map to create the tunnel on.</param>
            <param name="startX">X-value of the start position to connect.</param>
            <param name="startY">Y-value of the start position to connect.</param>
            <param name="endX">X-value of the end position to connect.</param>
            <param name="endY">Y-value of the end position to connect.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.OrderedMapAreaConnector">
            <summary>
            Same as ClosestMapAreaConnector, but connects random rooms instead of determining the closest
            one, or connects rooms in the order specified if you give it a list of MapAreas.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.OrderedMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},GoRogue.AdjacencyRule,GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator,Troschuetz.Random.IGenerator,System.Boolean)">
            <summary>
            Connects the areas by determining all unique areas on the map given using a
            MapAreaFinder, then, if randomizeOrder is true, performing a Fisher Yates shuffle of that
            list of areas found. It then simply connects areas adjacent to each other in that list,
            using the methods specified to determine points within two areas to connect, and how to
            create the tunnel between the two points.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="adjacencyRule">
            Method of adjacency to respect when determining map areas. Cannot be diagonal.
            </param>
            <param name="areaConnector">
            The method to use to determine the points from two areas to make a tunnel between, in
            order to connect those two areas. If null is specified, a RandomConnectionPointSelector
            is used, that uses the RNG passed into this function.
            </param>
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified,
            HorizontalVerticalTunnelCreator that utilizes the RNG passed into this function is used.
            </param>
            <param name="rng">The rng to use. If null is specified, the default rng is assumed.</param>
            <param name="randomizeOrder">
            Whether or not to randomize which room is connected to which -- if this is set to false,
            they will be conencted in the exact order they are returned from the MapAreaFinder.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.OrderedMapAreaConnector.Connect(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Collections.Generic.IReadOnlyList{GoRogue.MapGeneration.IReadOnlyMapArea},GoRogue.MapGeneration.Connectors.IAreaConnectionPointSelector,GoRogue.MapGeneration.Connectors.ITunnelCreator)">
            <summary>
            Connects the areas by simply connecting areas adjacent to each other in the passed in
            list of areas, using the methods specified to determine points within two areas to
            connect, and how to create the tunnel between the two points.
            </summary>
            <param name="map">The map to connect.</param>
            <param name="mapAreas">
            The list of map areas to connect, in the order they should be connected.
            </param>
            <param name="areaConnector">
            The method to use to determine the points from two areas to make a tunnel between, in
            order to connect those two areas. If null is specified, a RandomConnectionPointSelector
            is used, that uses the default RNG.
            </param>
            <param name="tunnelCreator">
            The tunnel creation strategy to use. If null is specified,
            HorizontalVerticalTunnelCreator that utilizes the default RNG is used.
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector">
            <summary>
            Implements a the selection algorithm that simply selects random points from the given
            MapArea's positions lists, using the RNG specified, or the default rng if null is given.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector.#ctor(Troschuetz.Random.IGenerator)">
            <summary>
            Constructor. Specifies the RNG to use, or null if the default RNG should be used.
            </summary>
            <param name="rng">The RNG to use, or null if the default RNG should be used.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RandomConnectionPointSelector.SelectConnectionPoints(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Selects and returns a random point from each map area's positions list.
            </summary>
            <param name="area1">First map area to connect.</param>
            <param name="area2">Second area to connect</param>
            <returns>A tuple containing the selected Coords.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Connectors.RoomDoorConnector">
            <summary>
            Opens up room walls to connect tunnels that are placed near rooms.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RoomDoorConnector.ConnectRooms(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Collections.Generic.IEnumerable{GoRogue.Rectangle},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Detects tunnels near the specified rooms and tries to open a wall spot to represent a door.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rooms">A collection of rooms to process.</param>
            <param name="minSidesToConnect">Minimum sides of the room to process.  Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process.  Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">A chance out of 100 to cancel selecting sides to process (per room).  Defaults to 50.</param>
            <param name="cancelConnectionPlacementChance">A chance out of 100 to cancel placing a door on a side after one has been placed (per room).
            Defaults to 70.</param>
            <param name="cancelConnectionPlacementChanceIncrease">Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each time a door
            is placed (per room).  Defaults to 10.</param>
            <returns>A list of rooms and the connections placed.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Connectors.RoomDoorConnector.ConnectRooms(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Collections.Generic.IEnumerable{GoRogue.Rectangle},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Detects tunnels near the specified rooms and tries to open a wall spot to represent a door.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rng">The RNG to use.</param>
            <param name="rooms">A collection of rooms to process.</param>
            <param name="minSidesToConnect">Minimum sides of the room to process.  Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process.  Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">A chance out of 100 to cancel selecting sides to process (per room).  Defaults to 50.</param>
            <param name="cancelConnectionPlacementChance">A chance out of 100 to cancel placing a door on a side after one has been placed (per room).
            Defaults to 70.</param>
            <param name="cancelConnectionPlacementChanceIncrease">Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each time a door
            is placed (per room).  Defaults to 10.</param>
            <returns>A list of rooms and the connections placed.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.BasicRoomsGenerator">
            <summary>
            Carves out non-overlapping rooms in a map using a basic process of generating a room, and trying to place that room without intersecting another.
            Generated rooms will not overlap with each other or existing open areas on the given map.  Generated rooms will not be connected -- for automatic
            connection of rooms generated by this algorithm, see GoRogue.MapGeneration.QuickGenerator.GenerateRandomRoomsMap().
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.BasicRoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates rooms and adds them to the given map. After this function has been completed, room floor tiles will have a
            value of true in the ISettableMapView given.  The value at wall locations will not be modified from the state in which they were passed in.
            </summary>
            <remarks>
            It is guaranteed that the "set" function of the ISettableMapView passed in will only be
            called once per tile at maximum.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the room.
            </param>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.BasicRoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates rooms and adds them to the given map. After this function has been completed, room floor tiles will have a
            value of true in the ISettableMapView given.  The value at wall locations will not be modified from the state in which they were passed in.
            </summary>
            <remarks>
            It is guaranteed that the "set" function of the ISettableMapView passed in will only be
            called once per tile at maximum.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="rng">The RNG to use to place rooms and determine room size. If null is specified, the default RNG is used.</param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the room.
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.CellularAutomataAreaGenerator">
            <summary>
            Implements a cellular automata genereation algorithm to add cave-like (unconnected) areas to a map. A connection algorithm would be needed to connect
            these areas.  For automatic connection, see GoRogue.MapGeneration.QuickGenerators.CellularAutomata().
            </summary>
            <remarks>
            Generates a map by randomly filling the map surface with floor or wall values (true and false
            respectively) based on a probability given, then iteratively smoothing it via the process
            outlined in the cited roguebasin article. After generate is called, the passed in map
            will have had a value of true set to all floor tiles, and a value of false set to all wall
            tiles. Based on the C# roguelike library RogueSharp's implementation, and the roguebasin
            article below:
            http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels.
            It is guaranteed that the "set" function of the ISettableMapView passed in will only be
            called once per tile, unless the type is ArrayMap of bool, in which case the operation is
            inexpensive and calling it multiples times costs little extra, and saves an internal allocation.
            </remarks>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.CellularAutomataAreaGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates the areas. Floor tiles will be set to true in the provided map, and wall tiles
            will be set to false.
            </summary>
            <param name="map">The map to fill with values when generate is called.</param>
            <param name="rng">
            The RNG to use to initially fill the map. If null is specified, the default RNG is used.
            </param>
            <param name="fillProbability">
            Represents the percent chance that a given cell will be a floor cell when the map is
            initially randomly filled. Recommended to be in range [40, 60] (40 is used in the
            roguebasin article).
            </param>
            <param name="totalIterations">
            Total number of times the cellular automata-based smoothing algorithm is executed.
            Recommended to be in range [2, 10] (7 is used on roguebasin article).
            </param>
            <param name="cutoffBigAreaFill">
            Total number of times the cellular automata smoothing variation that is more likely to
            result in "breaking up" large areas will be run before switching to the more standard
            nearest neighbors version. Recommended to be in range [2, 7] (4 is used in roguebasin article).
            </param>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.MazeGenerator">
            <summary>
            Generates a maze, and adds it to the given map.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.MazeGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32)">
            <summary>
            Generates a maze in map using crawlers that walk the map carving tunnels.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rng">The RNG to use.</param>
            <param name="crawlerChangeDirectionImprovement">Out of 100, how much to increase the chance of the crawler changing direction each step. Once it changes
            direction, the chance resets to 0 and increases by this amount.  Defaults to 10.</param>
            <param name="saveDeadEndChance">After the crawler finishes, the small dead ends will be trimmed out. This value indicates the chance out of 100 that the
            dead end remains.  Defaults to 0.</param>
        </member>
        <member name="T:GoRogue.MapGeneration.Generators.RoomsGenerator">
            <summary>
            Carves out non-overlapping rooms in a map.  Rooms generated will not overlap with themselves, or any existing open areas on the given map. Rooms
            will not be connected -- for automatic connection of rooms generated by this generator, see
            GoRogue.MapGeneration.QuickGenerator.GenerateDungeonMazeMap().
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.RoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Carves random rectangles out of the map, setting the interior of the room to true. Does not set the wall of the rooms to false.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">The ratio of the room width to the height.  Defaults to 1.0.</param>
            <param name="roomSizeRatioY">The ratio of the room height to the width.  Defaults to 1.0.</param>
            <param name="maxCreationAttempts">The max times to re-generate a room that cannot be placed before giving up on placing that room.  Defaults to 10.</param>
            <param name="maxPlacementAttempts">The max times to attempt to place a room in a map without intersection, before giving up and re-generating that
            room.  Defaults to 10.</param>
            <returns>A collection of room rectangles that were added to the map.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.Generators.RoomsGenerator.Generate(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32)">
            <summary>
            Carves random rectangles out of the map, setting the interior of the room to true. Does not set the wall of the rooms to false.
            </summary>
            <param name="map">The map to modify.</param>
            <param name="rng">RNG to use.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">The ratio of the room width to the height. Defaults to 1.0.</param>
            <param name="roomSizeRatioY">The ratio of the room height to the width.  Defaults to 1.0.</param>
            <param name="maxCreationAttempts">The max times to re-generate a room that cannot be placed before giving up on placing that room.  Defaults to 10.</param>
            <param name="maxPlacementAttempts">The max times to attempt to place a room in a map without intersection, before giving up and re-generating that
            room.  Defaults to 10.</param>
            <returns>A collection of room rectangles that were added to the map.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.IReadOnlyMapArea">
            <summary>
            Read-only interface for an arbitrarily-shaped area of the map.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMapArea.Bounds">
            <summary>
            Smallest possible rectangle that encompasses every position in the area.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMapArea.Count">
            <summary>
            Number of (unique) positions in the currently stored list.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.IReadOnlyMapArea.Positions">
            <summary>
            List of all (unique) positions in the list.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Contains(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given MapArea is completely contained within the current one.
            </summary>
            <param name="area">MapArea to check.</param>
            <returns>
            True if the given MapArea is completely contained within the current one, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Contains(System.Int32,System.Int32)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="x">X-coordinate of the position to check.</param>
            <param name="y">Y-coordinate of the position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Contains(GoRogue.Coord)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="position">The position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.Intersects(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given map area intersects the current one. If you intend to
            determine/use the exact intersection based on this return value, it is best to instead
            call the MapArea.GetIntersection, and check the number of positions in the result (0 if
            no intersection).
            </summary>
            <param name="area">The MapArea to check.</param>
            <returns>True if the given MapArea intersects the current one, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.RandomPosition(Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the MapArea.
            </summary>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>A random position from within the MapArea.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.IReadOnlyMapArea.RandomPosition(System.Func{GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the MapArea for which the given selector returns true. Coords
            are repeatedly selected until a valid one is found.
            </summary>
            <param name="selector">
            A function that should return true for any coordinate that is a valid selection, and
            false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>
            A random position from within the MapArea for which the selector given returns true.
            </returns>
        </member>
        <member name="T:GoRogue.MapGeneration.MapArea">
            <summary>
            Represents an arbitrarily-shaped area of a map. Stores and provides access to a list of each
            unique position considered connected.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MapArea.Bounds">
            <summary>
            Smallest possible rectangle that encompasses every position in the area.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MapArea.Count">
            <summary>
            Number of (unique) positions in the currently stored list.
            </summary>
        </member>
        <member name="P:GoRogue.MapGeneration.MapArea.Positions">
            <summary>
            List of all (unique) positions in the list.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetDifference(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Gets a MapArea containing all positions in area1, minus those that are in area2.
            </summary>
            <param name="area1">The first MapArea.</param>
            <param name="area2">The second MapArea.</param>
            <returns>A MapArea with exactly those positions in area1 that are NOT in area2.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetIntersection(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Gets a MapArea containing exactly those positions in both of the given MapAreas.
            </summary>
            <param name="area1">First MapArea.</param>
            <param name="area2">Second MapArea.</param>
            <returns>A MapArea containing exactly those positions in both of the given MapAreas.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetUnion(GoRogue.MapGeneration.IReadOnlyMapArea,GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Gets a new MapArea containing exactly every position in one or both given map areas.
            </summary>
            <param name="area1">First MapArea.</param>
            <param name="area2">Second MapArea.</param>
            <returns>A MapArea containing only those positions in one or both of the given MapAreas.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.op_Inequality(GoRogue.MapGeneration.MapArea,GoRogue.MapGeneration.MapArea)">
            <summary>
            Inequality comparison -- true if the two areas do NOT contain exactly the same points.
            </summary>
            <param name="lhs">First MapArea to compare.</param>
            <param name="rhs">Second MapArea to compare.</param>
            <returns>True if the MapAreas do NOT contain exactly the same points, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.op_Addition(GoRogue.MapGeneration.MapArea,GoRogue.Coord)">
            <summary>
            Creates a new MapArea with the Coords all shifted by the given vector (Coord).
            </summary>
            <param name="lhs">MapArea.</param>
            <param name="rhs">Coord (vector) to add.</param>
            <returns>
            A new MapArea with the Coords all shifted by the given amount in x and y directions.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.op_Equality(GoRogue.MapGeneration.MapArea,GoRogue.MapGeneration.MapArea)">
            <summary>
            Compares for equality. Returns true if the two MapAreas are the same reference, or if
            they contain exactly the same points.
            </summary>
            <param name="lhs">First MapArea to compare.</param>
            <param name="rhs">Second MapArea to compare.</param>
            <returns>True if the MapAreas contain exactly the same points, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(GoRogue.Coord)">
            <summary>
            Adds the given position to the list of points within the area if it is not already in the
            list, or does nothing otherwise. Because the class uses a hash set internally to
            determine what points have already been added, this is an average case O(1) operation.
            </summary>
            <param name="position">The position to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(System.Collections.Generic.IEnumerable{GoRogue.Coord})">
            <summary>
            Adds the given positions to the list of points within the area if they are not already in
            the list.
            </summary>
            <param name="positions">Positions to add to the list.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(GoRogue.Rectangle)">
            <summary>
            Adds all positions in the given rectangle to the area, if they are not already present.
            </summary>
            <param name="rectangle">Rectangle whose points to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(System.Int32,System.Int32)">
            <summary>
            Adds the given position to the list of points within the area if it is not already in the
            list, or does nothing otherwise. Because the class uses a hash set internally to
            determine what points have already been added, this is an average case O(1) operation.
            </summary>
            <param name="x">X-coordinate of the position to add.</param>
            <param name="y">Y-coordinate of the position to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Add(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Adds all coordinates in the given map area to this one.
            </summary>
            <param name="area">Area containing positions to add.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Contains(GoRogue.Coord)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="position">The position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Contains(System.Int32,System.Int32)">
            <summary>
            Determines whether or not the given position is considered within the area or not.
            </summary>
            <param name="x">X-coordinate of the position to check.</param>
            <param name="y">Y-coordinate of the position to check.</param>
            <returns>True if the specified position is within the area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Contains(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given MapArea is completely contained within the current one.
            </summary>
            <param name="area">MapArea to check.</param>
            <returns>
            True if the given MapArea is completely contained within the current one, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Equals(System.Object)">
            <summary>
            Same as operator==. Returns false of obj is not a MapArea.
            </summary>
            <param name="obj">Object to compare</param>
            <returns>
            True if the object given is a MapArea and is equal (contains the same points), false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.GetHashCode">
            <summary>
            Returns hash of the underlying set.
            </summary>
            <returns>Hash code for the underlying set.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Intersects(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Returns whether or not the given map area intersects the current one. If you intend to
            determine/use the exact intersection based on this return value, it is best to instead
            call the MapArea.GetIntersection, and check the number of positions in the result (0 if
            no intersection).
            </summary>
            <param name="area">The MapArea to check.</param>
            <returns>True if the given MapArea intersects the current one, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.RandomPosition(Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the MapArea.
            </summary>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>A random position from within the MapArea.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.RandomPosition(System.Func{GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position from the MapArea for which the given selector returns true. Coords
            are repeatedly selected until a valid one is found.
            </summary>
            <param name="selector">
            A function that should return true for any coordinate that is a valid selection, and
            false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>
            A random position from within the MapArea for which the selector given returns true.
            </returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(GoRogue.Coord)">
            <summary>
            Removes the given position specified from the MapArea. Particularly when the Remove
            operation changes the bounds, this operation can be expensive, so if you must do multiple
            Remove operations, it would be best to group them into 1 using Remove(IEnumerable&lt;Coord&gt;).
            </summary>
            <param name="position">The position to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(System.Collections.Generic.IEnumerable{GoRogue.Coord})">
            <summary>
            Removes the given positions from the specified MapArea.
            </summary>
            <param name="positions">Positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(System.Int32,System.Int32)">
            <summary>
            Removes the given position specified from the MapArea. Particularly when the Remove
            operation changes the bounds, this operation can be expensive, so if you must do multiple
            Remove operations, it would be best to group them into 1 using Remove(IEnumerable&lt;Coord&gt;).
            </summary>
            <param name="x">X-coordinate of the position to remove.</param>
            <param name="y">Y-coordinate of the position to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(GoRogue.MapGeneration.IReadOnlyMapArea)">
            <summary>
            Removes all positions in the given MapArea from this one.
            </summary>
            <param name="area">Area containing positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.Remove(GoRogue.Rectangle)">
            <summary>
            Removes all positions in the given Rectangle from this MapArea.
            </summary>
            <param name="rectangle">Rectangle containing positions to remove.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapArea.ToString">
            <summary>
            Returns the string of each position in the MapArea, in a square-bracket enclosed list,
            eg. [(1, 2), (3, 4), (5, 6)].
            </summary>
            <returns>A string representation of those coordinates in the MapArea.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.MapAreaFinder">
            <summary>
            Class designed to calculate and produce a list of MapAreas representing each unique connected
            area of the map.
            </summary>
            <remarks>
            The class takes in an IMapView, where a value of true for a given position indicates it
            should be part of a map area, and false indicates it should not be part of any map area. In a
            classic roguelike dungeon example, this might be a walkability map where floors return a
            value of true and walls a value of false.
            </remarks>
        </member>
        <member name="F:GoRogue.MapGeneration.MapAreaFinder.AdjacencyMethod">
            <summary>
            The method used for determining connectivity of the grid.
            </summary>
        </member>
        <member name="F:GoRogue.MapGeneration.MapAreaFinder.Map">
            <summary>
            IMapView indicating which cells should be considered part of a map area and which should not.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.AdjacencyRule)">
            <summary>
            Constructor.
            </summary>
            <param name="map">
            IMapView indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.MapAreasFor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.AdjacencyRule)">
            <summary>
            Convenience function that creates an MapAreaFinder and returns the result of that
            MapAreaFinder's MapAreas function. Intended to be used for cases in which the area finder
            will never be re-used.
            </summary>
            <param name="map">
            IMapView indicating which cells should be considered part of a map area and which should not.
            </param>
            <param name="adjacencyMethod">The method used for determining connectivity of the grid.</param>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.MapAreaFinder.MapAreas">
            <summary>
            Calculates the list of map areas, returning each unique map area.
            </summary>
            <returns>An IEnumerable of each (unique) map area.</returns>
        </member>
        <member name="T:GoRogue.MapGeneration.QuickGenerators">
            <summary>
            Collection of algorithms that put map generation pieces together, in ways that allow you to quickly and easily generate a given type of map
            in a single function call.  The implementation of these functions may also be used as the basis for implementing more customized generation
            processes.
            </summary>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateRandomRoomsMap(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a map by attempting to randomly place the specified number of rooms, ranging in
            size between the specified min size and max size, trying the specified number of times to
            position a room without overlap before discarding the room entirely. The given map will have
            a value of false set to all non-passable tiles, and true set to all passable ones.
            </summary>
            <param name="map">The map to set values to.</param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the room. Defaults to 10.
            </param>
            <returns>Rectangles representing each room generated.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateRandomRoomsMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a map by attempting to randomly place the specified number of rooms, ranging in
            size between the specified min size and max size, trying the specified number of times to
            position a room without overlap before discarding the room entirely. The given map will have
            a value of false set to all non-passable tiles, and true set to all passable ones.
            </summary>
            <param name="map">The map to set values to.</param>
            <param name="rng">The RNG to use to place rooms and determine room size. If null is specified, the default RNG is used.</param>
            <param name="maxRooms">The maximum number of rooms to attempt to place on the map.</param>
            <param name="roomMinSize">The minimum size in width and height of each room.</param>
            <param name="roomMaxSize">The maximum size in width and height of each room.</param>
            <param name="attemptsPerRoom">
            The maximum number of times the position of a room will be generated to try to position
            it properly (eg. without overlapping with other rooms), before simply discarding the room.  Defaults to 10.
            </param>
            <returns>Rectangles representing each room generated.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateDungeonMazeMap(GoRogue.MapViews.ISettableMapView{System.Boolean},System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a dungeon map based on the process outlined here: http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/.
            </summary>
            <remarks>
            First, non-overlapping rooms are randomly placed using RoomGenerator.  Then, a maze is generated into the remaining space using a MazeGenerator.  Finally,
            the rooms are connected to each other using a RoomDoorConnector.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">The ratio of the room width to the height.  Defaults to 1.0.</param>
            <param name="roomSizeRatioY">The ratio of the room height to the width. Defaults to 1.0.</param>
            <param name="maxCreationAttempts">The max times to re-generate a room that cannot be placed before giving up on placing that room.  Defaults to 10.</param>
            <param name="maxPlacementAttempts">The max times to attempt to place a room in a map without intersection, before giving up and re-generating that
            room.  Defaults to 10.</param>
            <param name="crawlerChangeDirectionImprovement">Out of 100, how much to increase the chance of the crawler changing direction each step during maze
            generation. Once it changes direction, the chance resets to 0 and increases by this amount.  Defaults to 10.</param>
            <param name="saveDeadEndChance">After the maze generation finishes, the small dead ends will be trimmed out. This value indicates the chance out of 100 that
            the dead end remains. Defaults to 0.</param>
            <param name="minSidesToConnect">Minimum sides of the room to process.  Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process.  Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">A chance out of 100 to cancel selecting sides to process (per room) while we are connecting them.
            Defaults to 50.</param>
            <param name="cancelConnectionPlacementChance">A chance out of 100 to cancel placing a door on a side after one has already been placed (per room) during
            connection.Defaults to 70.</param>
            <param name="cancelConnectionPlacementChanceIncrease">Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each time a door
            is placed (per room) during the connection process.  Defaults to 10.</param>
            <returns>A list of rooms and the connections placed.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateDungeonMazeMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a dungeon map based on the process outlined here: http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/.
            </summary>
            <remarks>
            First, non-overlapping rooms are randomly placed using RoomGenerator.  Then, a maze is generated into the remaining space using a MazeGenerator.  Finally,
            the rooms are connected to each other using a RoomDoorConnector.
            </remarks>
            <param name="map">The map to set values to.</param>
            <param name="rng">The RNG to use. If null is specified, the default RNG is used.</param>
            <param name="minRooms">Minimum amount of rooms to generate.</param>
            <param name="maxRooms">Maximum amount of rooms to generate.</param>
            <param name="roomMinSize">The minimum size of the room. Forces an odd number.</param>
            <param name="roomMaxSize">The maximum size of the room. Forces an odd number.</param>
            <param name="roomSizeRatioX">The ratio of the room width to the height.  Defaults to 1.0.</param>
            <param name="roomSizeRatioY">The ratio of the room height to the width. Defaults to 1.0.</param>
            <param name="maxCreationAttempts">The max times to re-generate a room that cannot be placed before giving up on placing that room.  Defaults to 10.</param>
            <param name="maxPlacementAttempts">The max times to attempt to place a room in a map without intersection, before giving up and re-generating that
            room.  Defaults to 10.</param>
            <param name="crawlerChangeDirectionImprovement">Out of 100, how much to increase the chance of the crawler changing direction each step during maze
            generation. Once it changes direction, the chance resets to 0 and increases by this amount.  Defaults to 10.</param>
            <param name="saveDeadEndChance">After the maze generation finishes, the small dead ends will be trimmed out. This value indicates the chance out of 100 that
            the dead end remains. Defaults to 0.</param>
            <param name="minSidesToConnect">Minimum sides of the room to process.  Defaults to 1.</param>
            <param name="maxSidesToConnect">Maximum sides of the room to process.  Defaults to 4.</param>
            <param name="cancelSideConnectionSelectChance">A chance out of 100 to cancel selecting sides to process (per room) while we are connecting them.
            Defaults to 50.</param>
            <param name="cancelConnectionPlacementChance">A chance out of 100 to cancel placing a door on a side after one has already been placed (per room) during
            connection.Defaults to 70.</param>
            <param name="cancelConnectionPlacementChanceIncrease">Increase the <paramref name="cancelConnectionPlacementChance"/> value by this amount each time a door
            is placed (per room) during the connection process.  Defaults to 10.</param>
            <returns>A list of rooms and the connections placed.</returns>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateRectangleMap(GoRogue.MapViews.ISettableMapView{System.Boolean})">
            <summary>
            Generates a map, as a simple rectangular box, setting the map given as a "walkability map". Wall tiles (the edges of
            the map) will have a value of false set in the given map, whereas true will be set to all
            non-wall tiles.
            </summary>
            <param name="map">The map to set values to.</param>
        </member>
        <member name="M:GoRogue.MapGeneration.QuickGenerators.GenerateCellularAutomataMap(GoRogue.MapViews.ISettableMapView{System.Boolean},Troschuetz.Random.IGenerator,System.Int32,System.Int32,System.Int32)">
            <summary>
            Generates a cave-like map using the cellular automata algorithm here:
            http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels.  See CellularAutomataAreaGenerator
            for details.  This algorithm is identical, except that it connects the areas automatically afterward.
            </summary>
            <param name="map"></param>
            <param name="rng"></param>
            <param name="fillProbability"></param>
            <param name="totalIterations"></param>
            <param name="cutoffBigAreaFill"></param>
            <returns></returns>
        </member>
        <member name="T:GoRogue.MapViews.ArrayMap`1">
            <summary>
            Default implementation of the ISettableMapView interface, exposing the interface using an
            actual 2D array to store data.
            </summary>
            <typeparam name="T">The type of value being stored.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor. Takes width and height of array.
            </summary>
            <param name="width">Width of array.</param>
            <param name="height">Height of array.</param>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Height">
            <summary>
            The height of the array.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Width">
            <summary>
            The width of the array.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns/sets the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ArrayMap`1.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, returns/sets the "value" associated with that location.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>THe "value" associated with the provided location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.Clone">
            <summary>
            Performs deep copy of array map.
            </summary>
            <returns>The cloned ArrayMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.SetToDefault">
            <summary>
            Sets each element in the ArrayMap to the default fo type T.
            </summary>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.ToString">
            <summary>
            Returns a string representation of the 2D array.
            </summary>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the 2D array, using the elementStringifier function
            given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an ArrayMap of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.MapViews.ArrayMap`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the ArrayMap, using the function specified to turn elements into
            strings, and using the "field length" specified. Each element of type T will have spaces
            added to cause it to take up exactly fieldSize characters, provided fieldSize is less
            than the length of the element's string represention. A positive-number right-aligns the
            text within the field, while a negative number left-aligns the text.
            </summary>
            <param name="fieldSize">The size of the field to give each value.</param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. Null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the ArrayMap.</returns>
        </member>
        <member name="T:GoRogue.MapViews.IMapView`1">
            <summary>
            Interface designed to act as a standardized input/output for algorithms.
            </summary>
            <remarks>
            Many roguelike/2D grid algorithms, such as pathfinding, FOV, and map generation, view a map
            as simply a 2D array of some type. In many games, however, the "value" associated with each
            2D position may be dependent upon many different things. For example, pathfinding, as input,
            often needs a "walkability map" -- in common terms, a 2D array of bools where the boolean
            value at each position represents whether or not that tile is passable with respect to
            pathing. This boolean value might be determined by a number of things - terrain type, monster
            positions, etc. Thus, in practice, maintaining an actual 2D array of boolean values that such
            an algorithm could take as input can be significant work. /// IMapView solves this problem by
            providing an interface that all such algorithms can take as input -- pathfinding, for
            instance, would take an IMapView&lt;bool&gt; instance, rather than a 2D array of booleans. A
            user of that algorithm might create a class that implements the indexers below to check the
            terrain type, if there is a monster at the position, etc., and returns the correct value.
            This prevents the need to maintain an actual 2D array in code that pathfinding can use, if
            such an array does not fit with your game architecture. /// If an actual 2D array is desired,
            a class ArrayMap is provided that implements IMapView, and acts much like an actual 2D array.
            </remarks>
            <typeparam name="T">The type of value being returned by the indexer functions.</typeparam>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Height">
            <summary>
            The height of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Width">
            <summary>
            The width of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, should return the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.IMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, should return the "value" associated with that location.
            </summary>
            <param name="pos">Location to retrieve the value for.</param>
            <returns>The "value" associated with the provided location.</returns>
        </member>
        <member name="T:GoRogue.MapViews.IMapViewExtensions">
            <summary>
            Extensions for the IMapView class that effectively act as methods with default
            implementations for them.
            </summary>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.Bounds``1(GoRogue.MapViews.IMapView{``0})">
            <summary>
            Gets a rectangle representing the bounds of the MapView.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to get bounds for -- never specified manually as this is an extension method
            </param>
            <returns>A rectangle representing the MapView's bounds.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.Positions``1(GoRogue.MapViews.IMapView{``0})">
            <summary>
            Iterates through each position in the map view. Equivalent to nested for loop for (y =
            0...) for (x = 0...)
            </summary>
            <typeparam name="T">Type of elements in the map view.</typeparam>
            <param name="mapView">
            Map view to iterate over positions for. Never specified manually since this is an
            extension method.
            </param>
            <returns>All positions in the IMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomItem``1(GoRogue.MapViews.IMapView{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets the value at a random position in the MapView.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>The item at a random position in the MapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomItem``1(GoRogue.MapViews.IMapView{``0},System.Func{GoRogue.Coord,``0,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets the item at a random position in the map view, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="selector">
            Function that takes a Coord and the value at that Coord, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>The item at a random position in the MapView for which the selector returns true.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},``0,Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, whose value in that map view is the specified
            one. Random positions will continually be generated until one with the specified value is found.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="validValue">
            A value to look for in the MapView to determine whether or not a generated Coord is valid.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>A random position whose value in this MapView is equal to the one specified.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},System.Collections.Generic.IEnumerable{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, whose value in map view is one of the ones
            specified. Random positions will continually be generated until one that has one of the
            specified values is found.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="validValues">
            A set of values to look for in the MapView to determine whether or not a generated Coord
            is valid.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>
            A random position whose value in this MapView is equal to one of the values specified.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},System.Collections.Generic.HashSet{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, whose value in map view is one of the ones
            specified in the HashSet. Random positions will continually be generated until one that has one of the
            specified values is found. 
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="validValues">
            A set of values to look for in the MapView to determine whether or not a generated Coord
            is valid.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>
            A random position whose value in this MapView is equal to one of the values specified.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},Troschuetz.Random.IGenerator,``0[])">
            <summary>
            Gets a random position in the map view, whose value in map view is one of the ones
            specified in validValues. Random positions will continually be generated until one that has one of the
            specified values is found.  
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <param name="validValues">
            A set of values to look for in the MapView to determine whether or not a generated Coord
            is valid.
            </param>
            <returns>
            A random position whose value in this MapView is equal to one of the values specified.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},System.Func{GoRogue.Coord,``0,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position in the map view, for which the selector returns true. Random
            positions will continuously be generated until one that qualifies is found.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="selector">
            Function that takes a Coord and the value at that Coord, and returns true if it is an
            acceptable selection, and false if not.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>A random position in the MapView for which the selector returns true.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.RandomPosition``1(GoRogue.MapViews.IMapView{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Gets a random position within the MapView.
            </summary>
            <typeparam name="T">Type of items being exposed by the MapView.</typeparam>
            <param name="mapView">
            Map view to select from -- never specified manually as this is an extension method.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>A random position within the MapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.ExtendToString``1(GoRogue.MapViews.IMapView{``0},System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for IMapViews allowing printing the contents. Takes characters
            to surround the map printout, and each row, the method used to get the string representation of
            each element (defaulting to the ToString function of type T), and separation characters
            for each element and row.
            </summary>
            <typeparam name="T">Type of elements in the IMapView.</typeparam>
            <param name="map">
            The IMapView to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="begin">Character(s) that should precede the IMapView printout.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the IMapView printout.</param>
            <returns>
            A string representation of the map, as viewd by the given map view.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.ExtendToString``1(GoRogue.MapViews.IMapView{``0},System.Int32,System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for IMapViews allowing printing the contents. Takes characters
            to surround the map, and each row, the method used to get the string representation of
            each element (defaulting to the ToString function of type T), and separation characters
            for each element and row. Takes the size
            of the field to give each element, characters to surround the MapView printout, and each row, the
            method used to get the string representation of each element (defaulting to the ToString
            function of type T), and separation characters for each element and row.
            </summary>
            <typeparam name="T">Type of elements in the 2D array.</typeparam>	
            <param name="map">
            The IMapView to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="fieldSize">
            The amount of space each element should take up in characters. A positive number aligns
            the text to the right of the space, while a negative number aligns the text to the left.
            </param>
            <param name="begin">Character(s) that should precede the IMapView printout.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the IMapView printout.</param>
            <returns>
            A string representation of the map, as viewd by the given map view.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.IMapViewExtensions.ApplyOverlay``1(GoRogue.MapViews.ISettableMapView{``0},GoRogue.MapViews.IMapView{``0})">
            <summary>
            Extension method that applies values of the overlay to the current one -- effectively
            sets all the values of the current map to be corresponding to the one you pass in.
            </summary>
            <param name="self">The current ISettableMapView.  Never specified manually as this is an extension method.</param>
            <param name="overlay">
            The data apply to the map. Must have identical dimensions to the current map.
            </param>
        </member>
        <member name="T:GoRogue.MapViews.ISettableMapView`1">
            <summary>
            Interface designed to act as a standardized input/output for algorithms that need to make
            modifications to data.
            </summary>
            <remarks>
            See IMapView documentation. Algorithms such as map generation may need to modify their
            inputs. Again, creating an actual 2D array can be tedious, depending on the application. As
            such, this interface extends IMapView to provide the capability to "set" values. /// Again,
            in case an actual 2D array is desired, ArrayMap implements this interface and provides a
            similar interface.
            </remarks>
            <typeparam name="T">The type of value being returned/set by the indexer functions.</typeparam>
        </member>
        <member name="P:GoRogue.MapViews.ISettableMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, should return/set the "value" associated with that location.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.ISettableMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, should return/set the "value" associated with that location.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>The "value" associated with the provided location.</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaMapView`1">
            <summary>
            Class designed to make implementing simple IMapViews more convenient, by providing the "get"
            functionality via a lambda function. For a version that implements ISettableMapView as
            opposed to IMapView, see LambdaSettableMapView.
            </summary>
            <remarks>
            Despite actual game map representations often consisting of complex types, exposing certain
            properties as primitive types (via IMapView implementations) for GoRogue algorithms to use is
            often fairly simple (simply exposing a property in the actual map class, or similar). If your
            map consists of Cells of some sort, where there exists an instance of some class/struct per
            location that contains information about that location, TranslationMap/LambdaTranslationMap
            provide convenient ways to implement simple IMapViews. In the case that no such single type
            exists, however, a more generic IMapView implementation is needed. This class takes the "get"
            function as a lambda to shorten the process of creating such an implementation.
            </remarks>
            <typeparam name="T">The type of value being returned by the indexer functions.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.#ctor(System.Int32,System.Int32,System.Func{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes the width and height of the map, and the function to use to retrieve
            the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the underlying representation do
            not change, so they can safely be passed in as constants.
            </remarks>
            <param name="width">The (constant) width of the map.</param>
            <param name="height">The (constant) height of the map.</param>
            <param name="valueGetter">
            A delegate/lambda that returns the value of type T associated with the location it is given.
            </param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.#ctor(System.Func{System.Int32},System.Func{System.Int32},System.Func{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes functions that retrieve the width and height of the map, and the
            function used to retrieve the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the map being represented may
            change -- one can provide lambdas that retrieve the width and height of the map being
            represented, and these lambdas will be called any time the Width and Height properties of
            this class are retrieved.
            </remarks>
            <param name="widthGetter">
            A delegate/lambda that retrieves the width of the map being represented.
            </param>
            <param name="heightGetter">
            A delegate/lambda that retrieves the height of the map being represented.
            </param>
            <param name="valueGetter">
            A delegate/lambda that returns the value of type T associated with the location it is given.
            </param>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Height">
            <summary>
            The height of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Width">
            <summary>
            The width of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, returns the "value" associated with that location, by calling the
            valueGetter lambda provided at construction.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>
            The "value" associated with that location, according to the valueGetter lambda provided
            at construction.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.LambdaMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, returns the "value" associated with that location, by calling the
            valueGetter lambda provided at construction.
            </summary>
            <param name="pos">Location to retrieve the value for.</param>
            <returns>
            The "value" associated with the provided location, according to the valueGetter lambda
            provided at construction.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.ToString">
            <summary>
            Returns a string representation of the LambdaMapView.
            </summary>
            <returns>A string representation of the LambdaMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the LambdaMapView, using the elementStringifier function
            given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an LambdaMapView of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the LambdaMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaMapView`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the LambdaMapView, using the function specified to turn elements into
            strings, and using the "field length" specified. Each element of type T will have spaces
            added to cause it to take up exactly fieldSize characters, provided fieldSize is less
            than the length of the element's string represention. A positive-number right-aligns the
            text within the field, while a negative number left-aligns the text.
            </summary>
            <param name="fieldSize">The size of the field to give each value.</param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. Null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the LambdaMapView.</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaSettableMapView`1">
            <summary>
            Class designed to make implementing simple ISettableMapViews more convenient, by providing
            the "get" and "set" functionality via lambda functions. For a version that implements
            IMapView as opposed to ISettableMapView, see LambdaMapView.
            </summary>
            <remarks>
            Despite actual game map representations often consisting of complex types, exposing certain
            properties as primitive types (via ISettableMapView implementations) for GoRogue algorithms
            to use is often fairly simple (simply exposing/translating to a property in the actual map
            class, or similar). If your map consists of Cells of some sort, where there exists an
            instance of some class/struct per location that contains information about that location,
            TranslationMap/LambdaTranslationMap provide convenient ways to implement simple
            ISettableMapViews. In the case that no such single type exists, however, a more generic
            IMapView implementation is needed. This class takes the "get" and "set" functions as lambdas
            to shorten the process of creating such an implementation.
            </remarks>
            <typeparam name="T">The type of value being returned by the indexer functions.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.#ctor(System.Int32,System.Int32,System.Func{GoRogue.Coord,`0},System.Action{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes the width and height of the map, and the functions to use to
            retrieve/set the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the underlying representation do
            not change, so they can safely be passed in as constants.
            </remarks>
            <param name="width">The (constant) width of the map.</param>
            <param name="height">The (constant) height of the map.</param>
            <param name="valueGetter">
            A delegate/lambda that returns the value of type T associated with the location it is given.
            </param>
            <param name="valueSetter">
            A delegate/lambda that updates the map being represented accordingly, given a type T and
            position to which it was set.
            </param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.#ctor(System.Func{System.Int32},System.Func{System.Int32},System.Func{GoRogue.Coord,`0},System.Action{GoRogue.Coord,`0})">
            <summary>
            Constructor. Takes functions that retrieve the width and height of the map, and the
            functions used to retrieve/set the value for a location.
            </summary>
            <remarks>
            This constructor is useful if the width and height of the map being represented may
            change -- one can provide lambdas that retrieve the width and height of the map being
            represented, and these lambdas will be called any time the Width and Height properties of
            this class are retrieved.
            </remarks>
            <param name="widthGetter">
            A delegate/lambda that retrieves the width of the map being represented.
            </param>
            <param name="heightGetter">
            A delegate/lambda that retrieves the height of the map being represented.
            </param>
            <param name="valueGetter">
            A delegate/lambda that returns the value of type T associated with the location it is given.
            </param>
            <param name="valueSetter">
            A delegate/lambda that updates the map being represented accordingly, given a type T and
            position to which it was set.
            </param>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Height">
            <summary>
            The height of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Width">
            <summary>
            The width of the map being represented.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, sets/returns the "value" associated with that location, by
            calling the valueGetter/valueSetter lambda provided at construction.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>
            The "value" associated with that location, according to the valueGetter lambda provided
            at construction.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.LambdaSettableMapView`1.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, returns/sets the "value" associated with that location, by calling the
            valueGetter/valueSetter lambda provided at construction.
            </summary>
            <param name="pos">Location to retrieve the value for.</param>
            <returns>
            The "value" associated with the provided location, according to the valueGetter lambda
            provided at construction.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.ToString">
            <summary>
            Returns a string representation of the LambdaSettableMapView.
            </summary>
            <returns>A string representation of the LambdaSettableMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the LambdaSettableMapView, using the elementStringifier function
            given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an LambdaSettableMapView of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the LambdaSettableMapView.</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableMapView`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the LambdaSettableMapView, using the function specified to turn elements into
            strings, and using the "field length" specified. Each element of type T will have spaces
            added to cause it to take up exactly fieldSize characters, provided fieldSize is less
            than the length of the element's string represention. A positive-number right-aligns the
            text within the field, while a negative number left-aligns the text.
            </summary>
            <param name="fieldSize">The size of the field to give each value.</param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. Null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the LambdaSettableMapView.</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaSettableTranslationMap`2">
            <summary>
            A simple TranslationMap implementation that allows you to provide lambdas for the translation
            functions. For a version offering only "get" functionality, see LambdaTranslationMap.
            </summary>
            <remarks>
            If you have several views that simply expose a simple property of your underlying data, it
            could get tedious writing a TranslationMap for all of them. This class simplifies that task
            by letting you just provide the translation methods as delegates/lambdas without needing to
            build the rest of the infrastructure.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from, and getter/setter functions taking only a map value.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},System.Func{GoRogue.Coord,`0,`1},System.Func{GoRogue.Coord,`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from, and getter/setter functions taking a map value and its corresponding position.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.MapViews.ISettableMapView{`1},System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from and applies view data to it.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="overlay">
            The view data to apply to the map. Must have identical dimensions to baseMap.
            </param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.MapViews.ISettableMapView{`1},System.Func{GoRogue.Coord,`0,`1},System.Func{GoRogue.Coord,`1,`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from and applies view data to it.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="overlay">
            The view data to apply to the map. Must have identical dimensions to baseMap.
            </param>
            <param name="getter">The TranslateGet implementation.</param>
            <param name="setter">The TranslateSet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type by calling the lambda getter specified in the
            class constructor.
            </summary>
            <param name="position">Position corresponding to given data value of your map. </param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type (via the getter specified in the class constructor).</returns>
        </member>
        <member name="M:GoRogue.MapViews.LambdaSettableTranslationMap`2.TranslateSet(GoRogue.Coord,`1)">
            <summary>
            Translates the view type into the appropriate form for your map data, by calling the
            lambda setter specified in the class constructor.
            </summary>
            <param name="position">Position corresponding to the given mapped data type.</param>
            <param name="value">A value of the mapped data type.</param>
            <returns>The data value for your map, (via the setter specified in the class constructor).</returns>
        </member>
        <member name="T:GoRogue.MapViews.LambdaTranslationMap`2">
            <summary>
            A simple TranslationMap implementation that allows you to provide a lambda for the
            translation function. For a version offering "set" functionality, see SettableLambdaTranslationMap.
            </summary>
            <remarks>
            If you have several views that simply expose a simple property of your underlying data, it
            could get tedious writing a TranslationMap for all of them. This class simplifies that task
            by letting you just provide the translation method as a delegate/lambda, without needing to
            build the rest of the infrastructure.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.LambdaTranslationMap`2.#ctor(GoRogue.MapViews.IMapView{`0},System.Func{`0,`1})">
            <summary>
            Constructor. Takes an existing map view to create a view from and a getter function taking only a value of type T1.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaTranslationMap`2.#ctor(GoRogue.MapViews.IMapView{`0},System.Func{GoRogue.Coord,`0,`1})">
            <summary>
            Constructor. Takes an existing map view to create a view from and a getter function taking a value of type T1 and its corresponding position.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
            <param name="getter">The TranslateGet implementation.</param>
        </member>
        <member name="M:GoRogue.MapViews.LambdaTranslationMap`2.TranslateGet(`0)">
            <summary>
            Translates your map data into the view type by calling the lambda getter specified in the
            class constructor.
            </summary>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type (via the getter specified in the class constructor).</returns>
        </member>
        <member name="T:GoRogue.MapViews.SettableTranslationMap`2">
            <summary>
            Settable map view class capable of taking complex data and providing a simpler view of it.
            For a version that provides only "get" functionality, see TranslationMap.
            </summary>
            <remarks>
            Many GoRogue algorithms work on a IMapView of a simple data type, which is likely to be a
            poor match for your game's actual map data. For example, map generation works with bools, and
            FOV calculation with doubles, while your map data may model each map cell as a class or
            struct containing many different member values. This class allows you to build descendant
            classes that override the TranslateGet and TranslateSet method(s) for simple mapping, or the
            this[Coord] properties if you need full access to the underlying data for context, in order
            to present a simplified view of your data to an algorithm without having to create the large
            amount of duplicate code associated with multiple ISettableMapView instances that all extract
            data from a Cell or Tile class.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.MapViews.ISettableMapView{`1})">
            <summary>
            Constructor. Takes an existing map view to create a view from and applies view data to it.
            </summary>
            <remarks>
            Since this constructor must call TranslateSet to do so, do NOT call this constructor if
            the TranslateSet implementation depends on the derived class's constructor being
            completed to function properly.
            </remarks>
            <param name="baseMap">Your underlying map data.</param>
            <param name="overlay">
            The view data to apply to the map. Must have identical dimensions. to baseMap.
            </param>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.BaseMap">
            <summary>
            The underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Height">
            <summary>
            The height of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Width">
            <summary>
            The width of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, translates and returns/sets the "value" associated with that location.
            this[int x, int y] calls this indexer for its functionality, so overriding this
            functionality also changes that overload.
            </summary>
            <param name="pos">Location to get/set the value for.</param>
            <returns>The translated "value" associated with the provided location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.SettableTranslationMap`2.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, translates and returns/sets the "value" associated with that
            location. This function calls this[Coord pos], so override that indexer to change functionality.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The translated "value" associated with that location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateGet(`0)">
            <summary>
            Translates your map data into the view type.  Takes only a value from the underlying map.  If a position is also needed to perform
            the translation, use TranslateGet(Coord, T1) instead.
            </summary>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type.  Takes a value from the underlying map and the corresponding position for that value.  If a position
            is not needed to perform the translation, use TranslateGet(T1) instead.
            </summary>
            <param name="position">The position of the given data value from your map.</param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateSet(`1)">
            <summary>
            Translates the view type into the appropriate form for your map data.  Takes only a value from the underlying map.  If a position is also needed to perform
            the translation, use TranslateSet(Coord, T2) instead.
            </summary>
            <param name="value">A value of the mapped data type</param>
            <returns>The data value for your map.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.TranslateSet(GoRogue.Coord,`1)">
            <summary>
            Translates the view type into the appropriate form for your map data.  Takes a value from the underlying map, and it corresponding position. 
            If a position is not needed to perform the translation, use TranslateSet(T2) instead.
            </summary>
            <param name="position">The position of the given mapped data type.</param>
            <param name="value">A value of the mapped data type</param>
            <returns>The data value for your map.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.ToString">
            <summary>
            Returns a string representation of the SettableTranslationMap.
            </summary>
            <returns>A string representation of the SettableTranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.ToString(System.Func{`1,System.String})">
            <summary>
            Returns a string representation of the SettableTranslationMap, using the elementStringifier function
            given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an SettableTranslationMap of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the SettableTranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.SettableTranslationMap`2.ToString(System.Int32,System.Func{`1,System.String})">
            <summary>
            Prints the values in the SettableTranslationMap, using the function specified to turn elements into
            strings, and using the "field length" specified. Each element of type T will have spaces
            added to cause it to take up exactly fieldSize characters, provided fieldSize is less
            than the length of the element's string represention. A positive-number right-aligns the
            text within the field, while a negative number left-aligns the text.
            </summary>
            <param name="fieldSize">The size of the field to give each value.</param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. Null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the SettableTranslationMap.</returns>
        </member>
        <member name="T:GoRogue.MapViews.SettableViewport`1">
            <summary>
            Similar to Viewport, but implements ISettableMapView and thus implements set functionality
            via relative coordinates.
            </summary>
            <typeparam name="T">Type being exposed by MapView.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.SettableViewport`1.#ctor(GoRogue.MapViews.ISettableMapView{`0},GoRogue.Rectangle)">
            <summary>
            Constructor. Takes the MapView to represent, and the initial ViewArea for that map.
            </summary>
            <param name="mapView">The map view being represented.</param>
            <param name="viewArea">The initial ViewArea for that map.</param>
        </member>
        <member name="M:GoRogue.MapViews.SettableViewport`1.#ctor(GoRogue.MapViews.ISettableMapView{`0})">
            <summary>
            Constructor. Takes the MapView to represent. Initial ViewArea will be the entire MapView.
            </summary>
            <param name="mapView">The MapView to represent.</param>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.MapView">
            <summary>
            The MapView that this Viewport is exposing values from.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.Item(GoRogue.Coord)">
            <summary>
            Given a position in relative coordinates, sets/returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativePosition">
            Viewport-relative position of the location to retrieve/set the value for.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying MapView.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.SettableViewport`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value in relative coordinates, sets/returns the "value" associated with
            that location in absolute coordinates.
            </summary>
            <param name="relativeX">Viewport-relative X-value of location.</param>
            <param name="relativeY">Viewport-relative Y-value of location.</param>
            <returns>
            The "value" associated with the absolute location represented on the underlying MapView.
            </returns>
        </member>
        <member name="T:GoRogue.MapViews.TranslationMap`2">
            <summary>
            Map view class capable of taking complex data and providing a simpler view of it. For a
            version that provides "set" functionality, see SettableTranslationMap.
            </summary>
            <remarks>
            Many GoRogue algorithms work on a IMapView of a simple data type, which is likely to be a
            poor match for your game's actual map data. For example, map generation works with bools, and
            FOV calculation with doubles, while your map data may model each map cell as a class or
            struct containing many different member values. This class allows you to build descendant
            classes that override the TranslateGet method(s) for simple mapping, or the "this" indexers if
            you need full access to the underlying data for context, in order to present a simplified
            view of your data to an algorithm without having to create the large amount of duplicate code
            associated with multiple ISettableMapView instances that all extract data from a Cell or Tile class.
            </remarks>
            <typeparam name="T1">The type of your underlying data.</typeparam>
            <typeparam name="T2">The type of the data being exposed to the algorithm.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.#ctor(GoRogue.MapViews.IMapView{`0})">
            <summary>
            Constructor. Takes an existing map view to create a view from.
            </summary>
            <param name="baseMap">Your underlying map data.</param>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.BaseMap">
            <summary>
            The underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Height">
            <summary>
            The height of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Width">
            <summary>
            The width of the underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value, translates and returns the "value" associated with that location.
            This function calls this[Coord pos], so override that indexer to change functionality.
            </summary>
            <param name="x">X-value of location.</param>
            <param name="y">Y-value of location.</param>
            <returns>The translated "value" associated with that location.</returns>
        </member>
        <member name="P:GoRogue.MapViews.TranslationMap`2.Item(GoRogue.Coord)">
            <summary>
            Given a Coord, translates and returns the "value" associated with that location. this[int
            x, int y] calls this indexer for its functionality, so overriding this functionality also
            changes that overload.
            </summary>
            <param name="pos">Location to get the value for.</param>
            <returns>The translated "value" associated with the provided location.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.ToString">
            <summary>
            Returns a string representation of the TranslationMap.
            </summary>
            <returns>A string representation of the TranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.ToString(System.Func{`1,System.String})">
            <summary>
            Returns a string representation of the TranslationMap, using the elementStringifier function
            given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an TranslationMap of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the TranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.ToString(System.Int32,System.Func{`1,System.String})">
            <summary>
            Prints the values in the TranslationMap, using the function specified to turn elements into
            strings, and using the "field length" specified. Each element of type T will have spaces
            added to cause it to take up exactly fieldSize characters, provided fieldSize is less
            than the length of the element's string represention. A positive-number right-aligns the
            text within the field, while a negative number left-aligns the text.
            </summary>
            <param name="fieldSize">The size of the field to give each value.</param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. Null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the TranslationMap.</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.TranslateGet(`0)">
            <summary>
            Translates your map data into the view type using just the map data value.  If you need the location to perform the translation, implement
            TranslateGet(Coord, T1) instead.
            </summary>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="M:GoRogue.MapViews.TranslationMap`2.TranslateGet(GoRogue.Coord,`0)">
            <summary>
            Translates your map data into the view type using the position and the map data value.  If you need only the data value to perform the translation, implement
            TranslateGet(T1) instead.
            </summary>
            <param name="position">The position of the given data value in your map.</param>
            <param name="value">The data value from your map.</param>
            <returns>A value of the mapped data type</returns>
        </member>
        <member name="T:GoRogue.MapViews.Viewport`1">
            <summary>
            Since some algorithms that use MapViews can be expensive to run entirely on large maps (such
            as GoalMaps), Viewport is a class that effectively creates and maintains a "viewport" of the
            map. Its indexers perform relative to absolute coordinate translations, and return the proper
            value of type T from the underlying map..
            </summary>
            <typeparam name="T">The type being exposed by the MapView.</typeparam>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.#ctor(GoRogue.MapViews.IMapView{`0},GoRogue.Rectangle)">
            <summary>
            Constructor. Takes the MapView to represent, and the initial ViewArea for that map.
            </summary>
            <param name="mapView">The map view being represented.</param>
            <param name="viewArea">The initial ViewArea for that map.</param>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.#ctor(GoRogue.MapViews.IMapView{`0})">
            <summary>
            Constructor. Takes the MapView to represent. Initial ViewArea will be the entire MapView.
            </summary>
            <param name="mapView">The MapView to represent.</param>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Height">
            <summary>
            The height of the ViewArea.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.MapView">
            <summary>
            The MapView that this Viewport is exposing values from.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.ViewArea">
            <summary>
            The area of the base MapView that this Viewport is exposing. Although this property does
            not explicitly expose a set accessor, it is returning a reference and as such may be
            assigned to. When accessed, the rectangle is automatically restricted by the edges of the
            map as necessary.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Width">
            <summary>
            The width of the ViewArea.
            </summary>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Item(GoRogue.Coord)">
            <summary>
            Given a position in relative coordinates, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativePosition">
            Viewport-relative position of the location to retrieve the value for.
            </param>
            <returns>
            The "value" associated with the absolute location represented on the underlying MapView.
            </returns>
        </member>
        <member name="P:GoRogue.MapViews.Viewport`1.Item(System.Int32,System.Int32)">
            <summary>
            Given an X and Y value in relative coordinates, returns the "value" associated with that
            location in absolute coordinates.
            </summary>
            <param name="relativeX">Viewport-relative X-value of location.</param>
            <param name="relativeY">Viewport-relative Y-value of location.</param>
            <returns>
            The "value" associated with the absolute location represented on the underlying MapView.
            </returns>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.ToString">
            <summary>
            Returns a string representation of the Viewport.
            </summary>
            <returns>A string representation of the Viewport.</returns>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the Viewport, using the elementStringifier function
            given to determine what string represents which value.
            </summary>
            <remarks>
            This could be used, for example, on an Viewport of boolean values, to output '#' for
            false values, and '.' for true values.
            </remarks>
            <param name="elementStringifier">
            Function determining the string representation of each element.
            </param>
            <returns>A string representation of the Viewport.</returns>
        </member>
        <member name="M:GoRogue.MapViews.Viewport`1.ToString(System.Int32,System.Func{`0,System.String})">
            <summary>
            Prints the values in the Viewport, using the function specified to turn elements into
            strings, and using the "field length" specified. Each element of type T will have spaces
            added to cause it to take up exactly fieldSize characters, provided fieldSize is less
            than the length of the element's string represention. A positive-number right-aligns the
            text within the field, while a negative number left-aligns the text.
            </summary>
            <param name="fieldSize">The size of the field to give each value.</param>
            <param name="elementStringifier">
            Function to use to convert each element to a string. Null defaults to the ToString
            function of type T.
            </param>
            <returns>A string representation of the Viewport.</returns>
        </member>
        <member name="T:GoRogue.MathHelpers">
            <summary>
            Static class consisting of mathematical "helper" functions and constants -- things like angle unit
            conversions, and other helpful functions.
            </summary>
        </member>
        <member name="F:GoRogue.MathHelpers.DEGREE_PCT_OF_CIRCLE">
            <summary>
            Result of 1/360; represents in decimal form a percent of a circle that a degree constitutes.
            </summary>
        </member>
        <member name="M:GoRogue.MathHelpers.RoundToMultiple(System.Int32,System.Int32)">
            <summary>
            Rounds the given number up (toward highest number), to the nearest multiple of the
            specified value.
            </summary>
            <param name="number">Number to round.</param>
            <param name="toMultipleOf">Number given is rounded up to nearest multiple of this number.</param>
            <returns>The number parameter, rouded up to the nearest multiple of toMultipleOf.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.ToDegree(System.Double)">
            <summary>
            Converts given angle from radians to degrees.
            </summary>
            <param name="radAngle">Angle in radians.</param>
            <returns>The given angle in degrees.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.ToRadian(System.Double)">
            <summary>
            Converts given angle from degrees to radians.
            </summary>
            <param name="degAngle">Angle in degrees.</param>
            <returns>The given angle in radians.</returns>
        </member>
        <member name="M:GoRogue.MathHelpers.WrapAround(System.Int32,System.Int32)">
            <summary>
            A modified modulo operator. Computes similar to num % wrapTo, following the formula (num
            % wrapTo + wrapTo) % wrapTo. Practically it differs from regular modulo in that the
            values it returns when negative values for num are given wrap around like one would want
            an array index to (if wrapTo is list.length, -1 wraps to list.length - 1). For example, 0
            % 3 = 0, -1 % 3 = -1, -2 % 3 = -2, -3 % 3 = 0, and so forth, but WrapTo(0, 3) = 0,
            WrapTo(-1, 3) = 2, -2 % 3 = 1, -3 % 3 = 0, and so forth. This can be useful if you're
            trying to "wrap" a number around at both ends, for example wrap to 3, such that 3 wraps
            to 0, and 0 wraps to 2. This is common if you are wrapping around an array index to the
            length of the array and need to ensure that positive numbers greater than or equal to the
            length of the array wrap to the beginning of the array (index 0), AND that negative
            numbers (under 0) wrap around to the end of the array (Length - 1). In that example to
            wrap a number i you would call WrapTo(i, array.Length).
            </summary>
            <param name="num">The number to wrap.</param>
            <param name="wrapTo">
            The number to wrap to -- the result of the function is as outlined in function
            description, and guaranteed to be between [0, wrapTo - 1], inclusive.
            </param>
            <returns>
            The wrapped result, as outlined in function description. Guaranteed to lie in range [0,
            wrapTo - 1], inclusive.
            </returns>
        </member>
        <member name="T:GoRogue.MultiSpatialMap`1">
            <summary>
            See SpatialMap documentation -- similar in principle. However, this implementation allows
            multiple items to exist at one point in the SpatialMap, in exchange for the loss of the
            convenience functions like GetItem vs GetItems, as well as potential performance differences
            (although unless the number of objects at any given location is large, the performance is
            asymptotically the same).
            </summary>
            <remarks>
            Although SpatialMap should generally be preferred in cases where only one item is allowed at
            a location in the first place, this implementation may be particularly useful for situations
            such as inventory items, where multiple items may be desired at one location. If one is
            implementing something akin to "buckets", one may also subclass this implementation and
            provide handlers to the various events it exposes to keep track of the object on top, etc.
            The two implementations could also in many cases be used in combination as necessary,
            since they both implement the ISpatialMap interface.
            </remarks>
            <typeparam name="T">The type of items being stored.  Must implement IHasID and be a reference-type.</typeparam>
        </member>
        <member name="M:GoRogue.MultiSpatialMap`1.#ctor(System.Int32)">
            <summary>
            Constructor. Creates an empty MultiSpatialMap.
            </summary>
            <param name="initialCapacity">
            The initial maximum number of elements the SpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="T:GoRogue.AdvancedMultiSpatialMap`1">
            <summary>
            Advanced version of MultiSpatialMap that allows for use of a custom IEqualityComparer for hashing and comparison of type T.
            May be useful for cases where one does not want to implement IHasID, or if you need to use a value type in a MultiSpatialMap.  For simple
            cases, it is recommended to use MultiSpatialMap instead.
            </summary>
            <remarks>
            Be mindful of the efficiency of your hashing function specified in the IEqualityComparer -- it will in large part determine the performance of
            AdvancedMultiSpatialMap!
            </remarks>
            <typeparam name="T">The type of object that will be contained by this AdvancedMultiSpatialMap.</typeparam>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            Constructor. Creates an empty MultiSpatialMap.
            </summary>
            <param name="comparer">Equality comparer to use for comparison and hashing of type T.  Be mindful of the efficiency
            of this instances GetHashCode function, as it will determine the efficiency of many AdvancedMultiSpatialMap functions.</param>
            <param name="initialCapacity">
            The initial maximum number of elements the MultiSpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="E:GoRogue.AdvancedMultiSpatialMap`1.ItemAdded">
            <summary>
            See ISpatialMap.ItemAdded.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedMultiSpatialMap`1.ItemMoved">
            <summary>
            See ISpatialMap.ItemMoved.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedMultiSpatialMap`1.ItemRemoved">
            <summary>
            See ISpatialMap.ItemRemoved.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedMultiSpatialMap`1.Count">
            <summary>
            See IReadOnlySpatialMap.Count.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedMultiSpatialMap`1.Items">
            <summary>
            See IReadOnlySpatialMap.Items.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedMultiSpatialMap`1.Positions">
            <summary>
            See IReadOnlySpatialMap.Positions.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            MultiSpatialMap. If the item is already contained in it, does nothing and returns false.
            Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="position">The position at which to add the new item.</param>
            <returns>True if the item was added, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            MultiSpatialMap. If the item is already contained in it, does nothing and returns false.
            Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="x">x-value of the position to add item to.</param>
            <param name="y">y-value of the position to add item to.</param>
            <returns>True if the item was added, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.AsReadOnly">
            <summary>
            Returns a ReadOnly reference to the SpatialMap. Convenient for "safely" exposing a
            SpatialMap as a property
            </summary>
            <returns>The current SpatialMap, as a "read-only" reference.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Clear">
            <summary>
            See IReadOnlySpatialMap.Clear.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Contains(`0)">
            <summary>
            See IReadOnlySpatialMap.Contains.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Contains(GoRogue.Coord)">
            <summary>
            See IReadOnlySpatialMap.Contains.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Contains(System.Int32,System.Int32)">
            <summary>
            See IReadOnlySpatialMap.Contains.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetEnumerator">
            <summary>
            Used by foreach loop, so that the class will give ISpatialTuple objects when used in a
            foreach loop. Generally should never be called explicitly.
            </summary>
            <returns>An enumerator for the SpatialMap</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Non-generic verion of enumerable used by foreach loop internally.
            </summary>
            <returns>Enumerator of ISpatialTuples.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetItems(GoRogue.Coord)">
            <summary>
            See IReadOnlySpatialMap.GetItems.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetItems(System.Int32,System.Int32)">
            <summary>
            See IReadOnlySpatialMap.GetItems.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.GetPosition(`0)">
            <summary>
            See IReadOnlySpatialMap.GetPosition.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Move the item specified to the position specified. Returns true if successful. If the
            item does not exist in the MultiSpatialMap, does nothing and returns false. Otherwise,
            returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="target">The position to move it to.</param>
            <returns>True if the item was moved, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Move the item specified to the position specified. Returns true if successful. If the
            item does not exist in the MultiSpatialMap, does nothing and returns false. Otherwise,
            returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="targetX">X-value of the location to move it to.</param>
            <param name="targetY">Y-value of the location to move it to.</param>
            <returns>True if the item was moved, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves everything at position current, if anything, to postion target. If something was
            moved, returns everything that was moved. If nothing was moved, eg. there was nothing at
            position current, returns nothing.
            </summary>
            <param name="current">The position of the items to move.</param>
            <param name="target">The position to move the item to.</param>
            <returns>The items moved if something was moved, or nothing if no item was moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves everything at position current, if anything, to postion target. If something was
            moved, returns everything that was moved. If nothing was moved, eg. there was nothing at
            position current, returns nothing.
            </summary>
            <param name="currentX">X-value of the location to move items from.</param>
            <param name="currentY">Y-value of the location to move items from.</param>
            <param name="targetX">X-value of the location to move items to.</param>
            <param name="targetY">Y-value of the location to move items to.</param>
            <returns>The items moved if something was moved, or nothing if no item was moved.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Remove(`0)">
            <summary>
            Removes the item specified, if it exists, and returns true. Returns false if the item was
            not in the MultiSpatialMap.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if the item was removed, false if the item was not found.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Remove(GoRogue.Coord)">
            <summary>
            Removes everything at the given position, if anything, and returns the items removed.
            Returns nothing if no item was at the position specified.
            </summary>
            <param name="position">The position of the item to remove.</param>
            <returns>
            The items removed, if any were removed; nothing if no item was found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes everything at the given position, if anything, and returns the items removed.
            Returns nothing if no item was at the position specified.
            </summary>
            <param name="x">X-value of the position to remove items from.</param>
            <param name="y">Y-value of the position to remove items from.</param>
            <returns>
            The items removed, if any were removed; nothing if no item was found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the MultiSpatialMap, allowing display of the
            MultiSpatialMap's items in a specified way.
            </summary>
            <param name="itemStringifier">Function that turns an item into a string.</param>
            <returns>A string representation of the MultiSpatialMap.</returns>
        </member>
        <member name="M:GoRogue.AdvancedMultiSpatialMap`1.ToString">
            <summary>
            Returns a string representation of the MultiSpatialMap.
            </summary>
            <returns>A string representation of the MultiSpatialMap.</returns>
        </member>
        <member name="T:GoRogue.Pathing.AStar">
            <summary>
            Implements basic AStar pathing. Distance specified determins the heuristic and connectivity
            (4-way vs. 8-way) assumed.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.AStar.#ctor(GoRogue.MapViews.IMapView{System.Boolean},GoRogue.Distance)">
            <summary>
            Constructor.
            </summary>
            <param name="walkabilityMap">
            Map used to determine whether or not a given location can be traversed -- true indicates
            walkable, false unwalkable.
            </param>
            <param name="distanceMeasurement">
            Distance measurement used to determine the method of measuring distance between two
            points, the heuristic AStar uses when pathfinding, and whether locations are connected in
            a 4-way or 8-way manner.
            </param>
        </member>
        <member name="P:GoRogue.Pathing.AStar.DistanceMeasurement">
            <summary>
            The distance calculation being used to determine distance between points. MANHATTAN
            implies 4-way connectivity, while CHEBYSHEV or EUCLIDEAN imply 8-way connectivity for the
            purpose of determining adjacent coordinates.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.AStar.WalkabilityMap">
            <summary>
            The map being used as the source for whether or not each tile is walkable.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.AStar.ShortestPath(GoRogue.Coord,GoRogue.Coord,System.Boolean)">
            <summary>
            Finds the shortest path between the two specified points.
            </summary>
            <remarks>
            Returns null if there is no path between the specified points. Will still return an
            appropriate path object if the start point is equal to the end point.
            </remarks>
            <param name="start">The starting point of the path.</param>
            <param name="end">The ending point of the path.</param>
            <param name="assumeEndpointsWalkable">
            Whether or not to assume the start and end points are walkable, regardless of what the
            walkability map reports. Defaults to true.
            </param>
            <returns>The shortest path between the two points, or null if no valid path exists.</returns>
        </member>
        <member name="M:GoRogue.Pathing.AStar.ShortestPath(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Finds the shortest path between the two specified points.
            </summary>
            <remarks>
            Returns null if there is no path between the specified points. Will still return an
            appropriate path object if the start point is equal to the end point.
            </remarks>
            <param name="startX">The x-coordinate of the starting point of the path.</param>
            <param name="startY">The y-coordinate of the starting point of the path.</param>
            <param name="endX">The x-coordinate of the ending point of the path.</param>
            <param name="endY">The y-coordinate of the ending point of the path.</param>
            <param name="assumeEndpointsWalkable">
            Whether or not to assume the start and end points are walkable, regardless of what the
            walkability map reports. Defaults to true.
            </param>
            <returns>The shortest path between the two points, or null if no valid path exists.</returns>
        </member>
        <member name="T:GoRogue.Pathing.Path">
            <summary>
            Encapsulates a path as returned by pathfinding algorithms like AStar.
            </summary>
            <remarks>
            Provides various functions to iterate through/access steps of the path, as well as
            constant-time reversing functionality.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.Path.#ctor(GoRogue.Pathing.Path,System.Boolean)">
            <summary>
            Creates a copy of the path, optionally reversing the path as it does so.
            </summary>
            <remarks>Reversing is an O(1) operation, since it does not modify the list.</remarks>
            <param name="pathToCopy">The path to copy.</param>
            <param name="reverse">Whether or not to reverse the path. Defaults to false.</param>
        </member>
        <member name="P:GoRogue.Pathing.Path.End">
            <summary>
            Ending point of the path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Length">
            <summary>
            The length of the path, NOT including the starting point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.LengthWithStart">
            <summary>
            The length of the path, INCLUDING the starting point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Start">
            <summary>
            Starting point of the path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.Steps">
            <summary>
            The coordinates that constitute the path (in order), NOT including the starting point.
            These are the coordinates something might walk along to follow a path.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.Path.StepsWithStart">
            <summary>
            The coordinates that constitute the path (in order), INCLUDING the starting point.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.Path.GetStep(System.Int32)">
            <summary>
            Gets the nth step along the path, where 0 is the step AFTER the starting point.
            </summary>
            <param name="stepNum">The (array-like index) of the step to get.</param>
            <returns>The coordinate consituting the step specified.</returns>
        </member>
        <member name="M:GoRogue.Pathing.Path.GetStepWithStart(System.Int32)">
            <summary>
            Gets the nth step along the path, where 0 IS the starting point.
            </summary>
            <param name="stepNum">The (array-like index) of the step to get.</param>
            <returns>The coordinate consituting the step specified.</returns>
        </member>
        <member name="M:GoRogue.Pathing.Path.Reverse">
            <summary>
            Reverses the path, in constant time.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.Path.ToString">
            <summary>
            Returns a string representation of all the steps in the path, including the start point,
            eg. [(1, 2), (3, 4), (5, 6)].
            </summary>
            <returns>A string representation of all steps in the path, including the start.</returns>
        </member>
        <member name="T:GoRogue.Pathing.FleeMap">
            <summary>
            Implements the concept of a "safety map", also known as "flee map", as described in the
            roguebasin article http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps.
            </summary>
            <remarks>
            Takes a goal map, wherein any goals are treated as "threats" to be avoided. Automatically
            recalculated when the underlying goal map is recalculated. Implements IDisposable, so ensure
            that it is disposed of properly after use.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.#ctor(GoRogue.Pathing.GoalMap,System.Double)">
            <summary>
            Constructor. Takes a goal map where in all goals are treated as threats to be avoided,
            and a magnitude to use (defaulting to 1.2).
            </summary>
            <param name="baseMap">The underlying goal map to use.</param>
            <param name="magnitude">Magnitude to multiply by during calculation.</param>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Height">
            <summary>
            Height of the flee map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Magnitude">
            <summary>
            The degree to which entities following this flee-map will prefer global safety to local
            safety. Higher values will make entities try to move past an approaching "threat" from
            farther away.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Width">
            <summary>
            Width of the flee map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Item(GoRogue.Coord)">
            <summary>
            Returns the flee-map value for the given position.
            </summary>
            <param name="pos">The position to return the value for.</param>
            <returns>The flee-map value for the given location.</returns>
        </member>
        <member name="P:GoRogue.Pathing.FleeMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="x">The x-value of the position to return the value for.</param>
            <param name="y">The y-value of the position to return the value for.</param>
            <returns>The flee-map value for the given location.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString">
            <summary>
            Returns the flee-map values represented as a 2D grid-style string.
            </summary>
            <returns>A string representing the flee map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.String)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, where any value that
            isn't null is formatted as per the specified format string.
            </summary>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.Int32)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, with the given field size.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.ToString(System.Int32,System.String)">
            <summary>
            Returns the flee-map values represented as a 2D-grid-style string, with the given field
            size, and any non-null values formatted using the given format string.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the flee-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.Finalize">
            <summary>
            Destructor for IDisposable implementation.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.FleeMap.Dispose">
            <summary>
            Function called to dispose of the class, automatically unlinking it from its goal map.
            </summary>
        </member>
        <member name="T:GoRogue.Pathing.GoalMap">
            <summary>
            Implementation of a goal map system, also known as Dijkstra maps (
            http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps )
            </summary>
            <remarks>
            This class encapsulates the work of building a goal map from your map level. You provide the
            constructor with a map level exposed as GoalStates (obstacle, a goal, or an open space), and
            GoalMap will compute the goal map for the level. /// When the underlying circumstances of the
            level change, the GoalMap instance will need to be updated. Call Update() if obstacles have
            changed, such as digging through walls or opening or closing a door, or UpdatePathsOnly() if
            the goals have changed but not the obstacles. /// Each cell is a Nullable&lt;double&gt;,
            where a null is an obstacle, and a value indicates a distance from a goal, with 0 being a
            goal tile.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.#ctor(GoRogue.MapViews.IMapView{GoRogue.Pathing.GoalState},GoRogue.Distance)">
            <summary>
            Constructor. Takes a base map and a distance measurement to use for calculation.
            </summary>
            <param name="baseMap">The underlying map as GoalStates.</param>
            <param name="distanceMeasurement">
            The distance measurement (and implicitly the AdjacencyRule) to use for calculation.
            </param>
        </member>
        <member name="E:GoRogue.Pathing.GoalMap.Updated">
            <summary>
            Triggers when the GoalMap is updated.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.BaseMap">
            <summary>
            The underlying map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.DistanceMeasurement">
            <summary>
            The distance measurement the GoalMap is using to calculate distance.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Height">
            <summary>
            Height of the goal map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Width">
            <summary>
            Width of the goal map.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="x">X-coordinate of the position to return the goal-map value for.</param>
            <param name="y">Y-coordinate of the position to return the goal-map value for.</param>
            <returns>The goal-map value for the given position.</returns>
        </member>
        <member name="P:GoRogue.Pathing.GoalMap.Item(GoRogue.Coord)">
            <summary>
            Returns the goal-map value for the given position.
            </summary>
            <param name="pos">The position to return the goal-map value for.</param>
            <returns>The goal-map value for the given position.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString">
            <summary>
            Returns the goal-map values represented as a 2D grid-style string.
            </summary>
            <returns>A string representing the goal map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.String)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, where any value that
            isn't null is formatted as per the specified format string.
            </summary>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.Int32)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, with the given field size.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.ToString(System.Int32,System.String)">
            <summary>
            Returns the goal-map values represented as a 2D-grid-style string, with the given field
            size, and any non-null values formatted using the given format string.
            </summary>
            <param name="fieldSize">Number of characters allocated to each value in the string.</param>
            <param name="formatString">Format string to use for non-null values.</param>
            <returns>A string representing the goal-map values.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.Update">
            <summary>
            Re-evaluates the entire goal map. Should be called when obstacles change. If the
            obstacles have not changed but the goals have, call UpdatePathsOnly() for better efficiency.
            </summary>
            <returns>False if no goals were produced by the evaluator, true otherwise</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.GetDirectionOfMinValue(GoRogue.Coord)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="position">The position to get the minimum value for.</param>
            <returns>The direction that has the minimum value in the goal-map, or Direction.NONE if the neighbors are all obstacles.</returns>
        </member>
        <member name="M:GoRogue.Pathing.GoalMap.UpdatePathsOnly">
            <summary>
            Re-evaluates the walkable portion of the goal map. Should be called anytime the goals change.
            </summary>
            <returns>False if no goals were produced by the evaluator, true otherwise</returns>
        </member>
        <member name="T:GoRogue.Pathing.GoalMapExtensions">
            <summary>
             Contains extensions for IMapView of nullable double values, that pertain generally to goal maps.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.GoalMapExtensions.GetDirectionOfMinValue(GoRogue.MapViews.IMapView{System.Nullable{System.Double}},GoRogue.Coord,GoRogue.AdjacencyRule)">
            <summary>
            Gets the direction of the neighbor with the minimum goal-map value from the given position.
            </summary>
            <param name="goalMap">The IMapView of nullable double values to operate on.  Never specified manually since this is an extension method.</param>
            <param name="position">The position to get the minimum value for.</param>
            <param name="adjacencyRule">The adjacency rule to use to determine neighbors.</param>
            <returns>The direction that has the minimum value in the goal-map, or Direction.NONE if the neighbors are all obstacles.</returns>
        </member>
        <member name="T:GoRogue.Pathing.GoalState">
            <summary>
            Used to determine the status of a tile for goal-mapping purposes.
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Obstacle">
            <summary>
            A tile that can't be entered and has to be routed around
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Clear">
            <summary>
            A tile that can be entered
            </summary>
        </member>
        <member name="F:GoRogue.Pathing.GoalState.Goal">
            <summary>
            A destination on the goal map.
            </summary>
        </member>
        <member name="T:GoRogue.Pathing.WeightedGoalMap">
            <summary>
            Implementation of the second half of the goal map system described in
            http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps , the ability
            to combine multiple goal maps with different weights.
            </summary>
            <remarks>
            This class encapsulates the work of building one overall goal map out of multiple existing
            maps. It holds references to one or more maps, each with its own "weight". The higher the
            weight value, the more strongly an AI will attempt to pursue this goal. A negative weight
            inverts the map, turning its goal into something to avoid.
            </remarks>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(GoRogue.MapViews.IMapView{System.Nullable{System.Double}})">
            <summary>
            Constructor. Takes a single goal map and assigns it a weight of 1.
            </summary>
            <param name="map">The goal map.</param>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(System.Collections.Generic.IEnumerable{GoRogue.MapViews.IMapView{System.Nullable{System.Double}}})">
            <summary>
            Constructor. Takes a sequence of goal maps and assigns each one a weight of 1.
            </summary>
            <param name="maps">The goal maps. Each one should be of the same size.</param>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.#ctor(System.Collections.Generic.IDictionary{GoRogue.MapViews.IMapView{System.Nullable{System.Double}},System.Double})">
            <summary>
            Constructor. Takes an existing goal map dictionary and copies it.
            </summary>
            <param name="maps">
            The goal maps. Each one should be of the same size, and all weights should have a nonzero value.
            </param>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Height">
            <summary>
            The height of the goal map, and its underlying maps.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Weights">
            <summary>
            The list of weighted goal maps. Can be used to add or remove goal maps, or change their weights.
            </summary>
            <remarks>
            When adding a new goal map, its Height and Width should be identical to the Height and
            Width of the GoalMapCombiner.
            </remarks>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Width">
            <summary>
            The width of the goal map, and its underlying maps.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Item(System.Int32,System.Int32)">
            <summary>
            Returns the value of the combined goal maps at any given point.
            </summary>
        </member>
        <member name="P:GoRogue.Pathing.WeightedGoalMap.Item(GoRogue.Coord)">
            <summary>
            Returns the value of the combined goal maps at any given point.
            </summary>
        </member>
        <member name="M:GoRogue.Pathing.WeightedGoalMap.Combine">
            <summary>
            Computes the entire aggregate goal map. This may be useful in situations where the goals
            are shared between many characters and do not change frequently.
            </summary>
        </member>
        <member name="T:GoRogue.Radius">
            <summary>
            Class representing different radius types. Similar in architecture to Coord in architecture
            -- it cannot be instantiated. Instead it simply has pre-allocated static variables for each
            type of radius, that should be used whenever a variable of type Radius is required.
            </summary>
            <remarks>
            Also contains utility functions to work with radius types, and is also implicitly convertible
            to the Distance class.
            </remarks>
        </member>
        <member name="F:GoRogue.Radius.CIRCLE">
            <summary>
            Radius is a circle around the center point. Shape that would represent movement radius in
            an 8-way movement scheme, with all movement cost the same based upon distance from the source.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.CUBE">
            <summary>
            Radius is a cube around the center point. Similar to SQUARE in 2d shape.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.DIAMOND">
            <summary>
            Radius is a diamond around the center point. Shape that would represent movement radius
            in a 4-way movement scheme.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.OCTAHEDRON">
            <summary>
            Radius is an octahedron around the center point. Similar to DIAMOND in 2d shape.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.SPHERE">
            <summary>
            Radius is a sphere around the center point. Similar to CIRCLE in 2d shape.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.SQUARE">
            <summary>
            Radius is a square around the center point. Shape that would represent movement radius in
            an 8-way movement scheme, with no additional cost on diagonal movement.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Type">
            <summary>
            Enum type corresponding to radius type being represented.
            </summary>
        </member>
        <member name="T:GoRogue.Radius.Types">
            <summary>
            Enum representing Radius types. Useful for easy mapping of radius types to a primitive
            type (for cases like a switch statement).
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.SQUARE">
            <summary>
            Type for Radius.SQUARE.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.DIAMOND">
            <summary>
            Type for Radius.DIAMOND.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.CIRCLE">
            <summary>
            Type for Radius.CIRCLE.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.CUBE">
            <summary>
            Type for Radius.CUBE.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.OCTAHEDRON">
            <summary>
            Type for Radius.OCTAHEDRON.
            </summary>
        </member>
        <member name="F:GoRogue.Radius.Types.SPHERE">
            <summary>
            Type for Radius.SPHERE.
            </summary>
        </member>
        <member name="M:GoRogue.Radius.op_Implicit(GoRogue.Radius)~GoRogue.AdjacencyRule">
            <summary>
            Allows implicit casting to AdjacencyRule type. The rule corresponding to the proper
            definition of distance to create the Radius casted will be retrieved.
            </summary>
            <param name="radius">Radius type being casted.</param>
        </member>
        <member name="M:GoRogue.Radius.op_Implicit(GoRogue.Radius)~GoRogue.Distance">
            <summary>
            Allows implicit casting to Distance type. The distance corresponding to the proper
            definition of distance to create the Radius casted will be retrieved.
            </summary>
            <param name="radius">Radius type being casted.</param>
        </member>
        <member name="M:GoRogue.Radius.ToRadius(GoRogue.Radius.Types)">
            <summary>
            Gets the Radius class instance representing the distance type specified.
            </summary>
            <param name="radiusType">The enum value for the distance method.</param>
            <returns>The radius class representing the given distance calculation.</returns>
        </member>
        <member name="M:GoRogue.Radius.ToString">
            <summary>
            Returns a string representation of the Radius.
            </summary>
            <returns>A string representation of the Radius.</returns>
        </member>
        <member name="T:GoRogue.RadiusAreaProvider">
            <summary>
            Class capable of getting all unique positions inside of a given radius and (optional) bounds.
            </summary>
            <remarks>
            In the case that MANHATTAN/CHEBYSHEV distance, or DIAMOND/SQUARE/OCTAHEDRON/CUBE shapes are
            used, Coords are guaranteed to be returned in order of distance from the center, from least
            to greatest. This guarantee does NOT hold if EUCLIDEAN distance, or CIRCLE/SPHERE radius
            shapes are specified. /// If no bounds are specified, the IEnumerable returned by positions
            will contain each coordinate within the radius. Otherwise, it will contain each coordinate in
            the radius that is also within the bounds of the rectangle. /// If the same radius length is
            being used multiple times (even from different center points), it is recommended to use only
            one RadiusAreaProvider, as the class allocates measurable memory, and using only one instance
            if the radius is used multiple times prevents reallocation. /// When the Radius value is
            changed, reallocation must be performed, however the overhead should be insignificant on
            everything but extremely large radiuses.
            </remarks>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(GoRogue.Coord,System.Int32,GoRogue.Distance,GoRogue.Rectangle)">
            <summary>
            Constructor. Specifies center, radius length, distance calculation that defines the
            concept of radius, and bounds.
            </summary>
            <param name="center">The center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius)..
            </param>
            <param name="bounds">The bounds to constrain the returned Coords to.</param>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(System.Int32,System.Int32,System.Int32,GoRogue.Distance,GoRogue.Rectangle)">
            <summary>
            Constructor. Specifies center, radius length, distance calculation that defines the
            concept of radius, and bounds.
            </summary>
            <param name="centerX">The x-value of the center point of the radius.</param>
            <param name="centerY">The y-value of the center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius)..
            </param>
            <param name="bounds">The bounds to constrain the returned Coords to.</param>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(GoRogue.Coord,System.Int32,GoRogue.Distance)">
            <summary>
            Constructor. Specifies center, radius length, and distance calculation that defines the
            concept of radius, with no bounds.
            </summary>
            <param name="center">The center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.#ctor(System.Int32,System.Int32,System.Int32,GoRogue.Distance)">
            <summary>
            Constructor. Specifies center, radius length, and distance calculation that defines the
            concept of radius, with no bounds.
            </summary>
            <param name="centerX">The x-value of the center point of the radius.</param>
            <param name="centerY">The y-value of the center point of the radius.</param>
            <param name="radius">The length of the radius.</param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.Bounds">
            <summary>
            The bounds to constrain the returned Coords to. Set to Rectangle.EMPTY to indicate that
            there are no bounds.
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.Center">
            <summary>
            The center point of the radius.
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </summary>
        </member>
        <member name="P:GoRogue.RadiusAreaProvider.Radius">
             <summary>
             The length of the radius, eg. the number of tiles from the center point (as defined by the distance
             calculation/radius shape given) to which the radius extends.
             </summary>
            <remarks>
             When this value is changed, reallocation of an underlying array is performed, however overhead should
             be relatively small in most cases.
             </remarks>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.AsReadOnly">
            <summary>
            Returns a read-only representation of this RadiusAreaProvider.
            </summary>
            <returns></returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.CalculatePositions">
            <summary>
            Calculates the new radius, and returns an IEnumerable of all unique Coords within that
            radius and bounds specified (as applicable). See class description for details on the ordering.
            </summary>
            <returns>Enumerable of all unique Coords within the radius and bounds specified.</returns>
        </member>
        <member name="M:GoRogue.RadiusAreaProvider.ToString">
            <summary>
            Returns a string representation of the parameters of the RadiusAreaProvider.
            </summary>
            <returns>A string representation of the RadiusAreaProvider.</returns>
        </member>
        <member name="T:GoRogue.Random.DiscreteConverter`1">
            <summary>
            Wraps a continuous distribution and allows it to be used as discrete, by rounding double
            values produced by NextDouble to nearest int. Its minimum, maximum, mean, median, variance,
            and mode(s) are exactly the same as its underlying IContinuousDistribution.
            </summary>
            <remarks>
            Takes a value of type T so that its ContinuousDistribution field can return a value of the
            exact wrapped type, which still enables access to any distribution-specified fields, etc.
            </remarks>
            <typeparam name="T">
            The type of continuous distribution being wrapped. Must implement IContinuousDistribution.
            </typeparam>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.#ctor(`0)">
            <summary>
            Constructor. Takes the continuous distribution to wrap.
            </summary>
            <param name="continuousDistribution">Continuous distribution instance to wrap around.</param>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.CanReset">
            <summary>
            Gets a value indicating whether the underlying random number distribution can be reset,
            so that it produces the same random number sequence again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.ContinuousDistribution">
            <summary>
            The continuous distribution being wrapped.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Generator">
            <summary>
            Gets the IGenerator object that is used as underlying random number generator.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Maximum">
            <summary>
            Gets the maximum possible value of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Mean">
            <summary>
            Gets the mean of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Median">
            <summary>
            Gets the median of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Minimum">
            <summary>
            Gets the minimum possible value of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Mode">
            <summary>
            Gets the mode of distributed random numbers.
            </summary>
        </member>
        <member name="P:GoRogue.Random.DiscreteConverter`1.Variance">
            <summary>
            Gets the variance of distributed random numbers for the underlying distribution.
            </summary>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.Next">
            <summary>
            Returns the result of the underlying continuous distribution's NextDouble function, but
            rounded to the nearest integer.
            </summary>
            <returns>
            The result of the underlying continuous distribution's NextDouble function, rounded to
            the nearest integer.
            </returns>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.NextDouble">
            <summary>
            Returns a distributed floating point random number from the underlying continuous generator.
            </summary>
            <returns>A distributed double-precision floating point number.</returns>
        </member>
        <member name="M:GoRogue.Random.DiscreteConverter`1.Reset">
            <summary>
            Resets the random number distribution, so that it produces the same random number
            sequence again.
            </summary>
            <returns>true if the random number distribution was reset; otherwise, false.</returns>
        </member>
        <member name="T:GoRogue.Random.DistributionHelpers">
            <summary>
            Defines functions that assist in dealing with RNG distributions.
            </summary>
        </member>
        <member name="M:GoRogue.Random.DistributionHelpers.CreateNormalDistribution(System.Double,System.Double,System.Double)">
            <summary>
            Creates a normal distribution based on a lower and upper value, and a distance to place
            those points from the mean. The mean is placed precisely in between the upper and lower
            values given, and the upper and lower values will both be exactly deviationsFromMean away
            from the mean.
            </summary>
            <param name="lower">Lower value by which to define the distribution.</param>
            <param name="upper">Upper value by which to define the distribution.</param>
            <param name="deviationsFromMean">
            Number of deviations from the mean at which to place the lower and upper values given.
            </param>
            <returns>
            A NormalDistribution constructed such that the mean is precisely in between the lower and
            upper values given, and the lower and upper values are exatly the specified number of
            deviations away from the mean.
            </returns>
        </member>
        <member name="M:GoRogue.Random.DistributionHelpers.CreateNormalDistribution(System.UInt32,System.Double,System.Double,System.Double)">
            <summary>
            Creates a normal distribution based on a lower and upper value, and a distance to place
            those points from the mean. The mean is placed precisely in between the upper and lower
            values given, and the upper and lower values will both be exactly deviationsFromMean away
            from the mean.
            </summary>
            <param name="seed">The seed to pass the default XorShift128Generator that is created.</param>
            <param name="lower">Lower value by which to define the distribution.</param>
            <param name="upper">Upper value by which to define the distribution.</param>
            <param name="deviationsFromMean">
            Number of deviations from the mean at which to place the lower and upper values given.
            </param>
            <returns>
            A NormalDistribution constructed such that the mean is precisely in between the lower and
            upper values given, and the lower and upper values are exatly the specified number of
            deviations away from the mean.
            </returns>
        </member>
        <member name="M:GoRogue.Random.DistributionHelpers.CreateNormalDistribution(Troschuetz.Random.IGenerator,System.Double,System.Double,System.Double)">
            <summary>
            Creates a normal distribution based on a lower and upper value, and a distance to place
            those points from the mean. The mean is placed precisely in between the upper and lower
            values given, and the upper and lower values will both be exactly deviationsFromMean away
            from the mean.
            </summary>
            <param name="generator">
            Generator to use. If null is specified, the default RNG will be used.
            </param>
            <param name="lower">Lower value by which to define the distribution.</param>
            <param name="upper">Upper value by which to define the distribution.</param>
            <param name="deviationsFromMean">
            Number of deviations from the mean at which to place the lower and upper values given.
            </param>
            <returns>
            A NormalDistribution constructed such that the mean is precisely in between the lower and
            upper values given, and the lower and upper values are exatly the specified number of
            deviations away from the mean.
            </returns>
        </member>
        <member name="T:GoRogue.Random.KnownSeriesGenerator">
            <summary>
            "Random number generator" that takes in a series of values, and simply returns them
            sequentially when RNG functions are called.
            </summary>
            <remarks>
            This class may be useful for testing, when you want to specify the numbers returned by an RNG
            without drastically modifying any code using the RNG.
            </remarks>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.UInt32},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Boolean},System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Creates a new known series generator, with parameters to indicate which series to use for
            the integer, unsigned integer, double, bool, and byte-based RNG functions. If null is
            specified, no values of that type may be returned, and functions that try to return a
            value of that type will throw an exception.
            </summary>
        </member>
        <member name="P:GoRogue.Random.KnownSeriesGenerator.CanReset">
            <summary>
            Whether or not the RNG is capable of resetting, such that it will return the same series
            of values again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.KnownSeriesGenerator.Seed">
            <summary>
            Since this RNG returns a known series of values, this field will always return 0.
            </summary>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Next(System.Int32)">
            <summary>
            Gets the next number in the underlying int series. If the value is less than 0 or greater
            than/equal to maxValue, throws an exception.
            </summary>
            <param name="maxValue">Maximum allowable number that can be returned (exclusive).</param>
            <returns>The appropriate number from the series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Next(System.Int32,System.Int32)">
            <summary>
            Gets the next number in the underlying series. If the value is less than minValue or
            greater than/equal to maxValue, throws an exception.
            </summary>
            <param name="minValue">Minimum allowable number that can be returned.</param>
            <param name="maxValue">Maximum allowable number that can be returned (exclusive).</param>
            <returns>The appropriate number from the series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Next">
            <summary>
            Gets the next integer in the underlying series. If the integer is equal to int.MaxValue,
            throws an exception.
            </summary>
            <returns>The next integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextBoolean">
            <summary>
            Returns the next boolean in the underlying series.
            </summary>
            <returns>The next boolean value in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextBytes(System.Byte[])">
            <summary>
            Fills the specified buffer with values from the underlying byte series.
            </summary>
            <param name="buffer">Buffer to fill.</param>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextDouble">
            <summary>
            Returns the next double in the underlying series. If the double is less than 0.0 or
            greater than/equal to 1.0, throws an exception.
            </summary>
            <returns>The next double in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextDouble(System.Double)">
            <summary>
            Returns the next double in the underlying series. If the double is less than 0.0 or
            greater than/equal to maxValue, throws an exception.
            </summary>
            <param name="maxValue">The maximum value for the returned value, exclusive.</param>
            <returns>The next double in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextDouble(System.Double,System.Double)">
            <summary>
            Returns the next double in the underlying series. If the double is less than minValue or
            greater than/equal to maxValue, throws an exception.
            </summary>
            <param name="minValue">Minimum value for the returned number, inclusive.</param>
            <param name="maxValue">Maximum value for the returned number, exclusive.</param>
            <returns>The next double in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextInclusiveMaxValue">
            <summary>
            Returns the next integer in the underlying series. If the value is less than 0, throws an exception.
            </summary>
            <returns>The next integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUInt">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is equal to
            uint.MaxValue, throws an exception.
            </summary>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUInt(System.UInt32)">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is greater than
            or equal to maxValue, throws an exception.
            </summary>
            <param name="maxValue">The maximum value for the returned number, exclusive.</param>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is less than
            minValue, or greater than/equal to maxValue, throws an exception.
            </summary>
            <param name="minValue">The minimum value for the returned number, inclusive.</param>
            <param name="maxValue">The maximum value for the returned number, exclusive.</param>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUIntExclusiveMaxValue">
            <summary>
            Returns the next unsigned integer in the underlying series. If the value is equal to
            uint.MaxValue, throws an exception.
            </summary>
            <returns>The next unsigned integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.NextUIntInclusiveMaxValue">
            <summary>
            Returns the next unsigned integer in the underlying series.
            </summary>
            <returns>The next unsinged integer in the underlying series.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Reset">
            <summary>
            Resets the random number generator, such that it starts returning values from the
            beginning of the underlying series.
            </summary>
            <returns>True, since the reset cannot fail.</returns>
        </member>
        <member name="M:GoRogue.Random.KnownSeriesGenerator.Reset(System.UInt32)">
            <summary>
            Resets the random number generator, such that it starts returning the values from the
            beginning of the underlying series.
            </summary>
            <param name="seed">Unused, since there is no seed for a known-series RNG.</param>
            <returns>True, since the reset cannot fail.</returns>
        </member>
        <member name="T:GoRogue.Random.MaxRandom">
            <summary>
            A "random" number generator that always returns the maxValue parameter given. Again this may
            be useful in testing, testing the upper range or repeatedly returning a value. Also used in
            DiceExpressions for certain max roll functions.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MaxRandom.CanReset">
            <summary>
            Whether or not the RNG is capable of resetting, such that it will return the same series
            of values again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MaxRandom.Seed">
             <summary>
             Since this RNG returns the maximum possible value, this field will always return 0.
            </summary>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Next">
            <summary>
            Returns int.MaxValue - 1.
            </summary>
            <returns>int.MaxValue - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Next(System.Int32)">
            <summary>
            Returns maxValue - 1.
            </summary>
            <param name="maxValue">Maximum bound of the returned number, exclusive.</param>
            <returns>maxValue - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns maxValue - 1.
            </summary>
            <param name="minValue">
            The minimum value that can be returned (unused since this generator always returns the maximum).
            </param>
            <param name="maxValue">The maximum value of the returned number, exclusive.</param>
            <returns>maxValue - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextBoolean">
            <summary>
            Returns true.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the given buffer with bytes of value byte.MaxValue.
            </summary>
            <param name="buffer">Buffer to fill.</param>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextDouble">
            <summary>
            Returns a number very close to (but still less than) 1.0.
            </summary>
            <remarks>Value returned is 0.99999999999999978.</remarks>
            <returns>A number very close to (but still ness than) 1.0.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextDouble(System.Double)">
            <summary>
            Returns a double very close to (but still less than) maxValue.
            </summary>
            <param name="maxValue">Maximum value for the returned value (exclusive).</param>
            <returns>A double very close to (but still less than) maxValue.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Returns a double very close to (but still less than) maxValue.
            </summary>
            <param name="minValue">
            Minimum value for the returned value. Unused since this generator always returns the
            maximum value.
            </param>
            <param name="maxValue">Maximum value for the returned value (exclusive).</param>
            <returns>A double very close to (but still less than) maxValue.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextInclusiveMaxValue">
            <summary>
            Returns int.MaxValue.
            </summary>
            <returns>int.MaxValue</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUInt">
            <summary>
            Returns uint.MaxValue.
            </summary>
            <returns>uint.MaxValue - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUInt(System.UInt32)">
            <summary>
            Returns maxValue - 1.
            </summary>
            <param name="maxValue">The maximum bound for the returned number, exclusive.</param>
            <returns>maxValue - 1</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Returns maxValue - 1.
            </summary>
            <param name="minValue">
            The minimum value that can be returned (unused since this generator always returns the maximum).
            </param>
            <param name="maxValue">The maximum bound for the returned number, exclusive.</param>
            <returns>maxValue - 1</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUIntExclusiveMaxValue">
            <summary>
            Returns uint.MaxValue - 1.
            </summary>
            <returns>uint.MaxValue - 1.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.NextUIntInclusiveMaxValue">
            <summary>
            Returns uint.MaxValue.
            </summary>
            <returns>uint.MaxValue.</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Reset">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:GoRogue.Random.MaxRandom.Reset(System.UInt32)">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <param name="seed">Unused, since this generator has no seed.</param>
            <returns>true</returns>
        </member>
        <member name="T:GoRogue.Random.MinRandom">
            <summary>
            A "random" number generator that always returns the minValue parameter given, or 0 on the
            Next overload that only takes maxValue. Again, may be useful for testing. Also used in
            DiceExpression for certain minimum roll functions.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MinRandom.CanReset">
            <summary>
            Whether or not the RNG is capable of resetting, such that it will return the same series
            of values again.
            </summary>
        </member>
        <member name="P:GoRogue.Random.MinRandom.Seed">
             <summary>
             Since this RNG returns the maximum possible value, this field will always return 0.
            </summary>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Next">
            <summary>
            Returns 0.0
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Next(System.Int32)">
            <summary>
            Returns 0.0
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Next(System.Int32,System.Int32)">
            <summary>
            Returns minValue.
            </summary>
            <param name="minValue">
            The minimum value for the returned number (which is always returned by this generator)
            </param>
            <param name="maxValue">
            The maximum value for the returned number (which is unused since this generator always
            returns the minimum.
            </param>
            <returns>minValue</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextBoolean">
            <summary>
            Returns false.
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextBytes(System.Byte[])">
            <summary>
            Fills the given buffer with bytes of value 0.
            </summary>
            <param name="buffer">The buffer to fill.</param>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextDouble">
            <summary>
            Returns 0.0.
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextDouble(System.Double)">
            <summary>
            Returns 0.0.
            </summary>
            <param name="maxValue">
            The maximum value for the returned number, exclusive. Unused since this function always
            returns the minimum.
            </param>
            <returns>0.0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Returns minValue.
            </summary>
            <param name="minValue">
            The minimum value for the returned number (always returned since this function always
            returns the minimum).
            </param>
            <param name="maxValue">The maximum vlaue for the returned number (unused).</param>
            <returns>minValue</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextInclusiveMaxValue">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUInt">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUInt(System.UInt32)">
            <summary>
            Returns 0.
            </summary>
            <param name="maxValue">
            The maximum value for the returned number (unused since this generator always returns the minimum).
            </param>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUInt(System.UInt32,System.UInt32)">
            <summary>
            Returns minValue.
            </summary>
            <param name="minValue">
            The minimum value for the returned number (this generator always returns the minimum value).
            </param>
            <param name="maxValue">The maximum value for the returned number (unused).</param>
            <returns>minValue</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUIntExclusiveMaxValue">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.NextUIntInclusiveMaxValue">
            <summary>
            Returns 0.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Reset">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:GoRogue.Random.MinRandom.Reset(System.UInt32)">
            <summary>
            Simply returns true, since this generator has no state.
            </summary>
            <param name="seed">Unused, since this generator has no seed.</param>
            <returns>true</returns>
        </member>
        <member name="T:GoRogue.Random.SingletonRandom">
            <summary>
            Static class that contains 1 variable, which is a DefaultRNG instance. Used as the default
            rng by other features (dice, etc) wherever needed, and can also be used if you need a random
            number generator for your own code.
            </summary>
        </member>
        <member name="F:GoRogue.Random.SingletonRandom.DefaultRNG">
            <summary>
            Settable field that specifies what IGenerator instance should be considered the default
            RNG. Defaults to an XorShift128Generator with a time-dependent value used as a seed.
            </summary>
        </member>
        <member name="T:GoRogue.Rectangle">
            <summary>
            Represents a rectangle in terms of grid squares. Provides numerous functions pertaining to area.
            </summary>
        </member>
        <member name="F:GoRogue.Rectangle.EMPTY">
            <summary>
            The empty rectangle. Has origin of (0, 0) with 0 width and height.
            </summary>
        </member>
        <member name="M:GoRogue.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor. Takes the minimum x and y values of the rectangle, along with the width and height.
            </summary>
            <param name="x">Minimum x coordinate that is inside the rectangle.</param>
            <param name="y">Minimum y coordinate that is inside the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
        </member>
        <member name="M:GoRogue.Rectangle.#ctor(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Constructor. Takes the minimum and maximum points that are considered within the rectangle.
            </summary>
            <param name="minExtent">Minimum x and y values that are considered inside the rectangle.</param>
            <param name="maxExtent">Maximum x and y values that are considered inside the rectangle.</param>
        </member>
        <member name="M:GoRogue.Rectangle.#ctor(GoRogue.Coord,System.Int32,System.Int32)">
            <summary>
            Constructor. Takes a center point, and horizontal/vertical radius defining the bounds.
            </summary>
            <param name="center">The center point of the rectangle.</param>
            <param name="horizontalRadius">
            Number of units to the left and right of the center point that are included within the rectangle.
            </param>
            <param name="verticalRadius">
            Number of units to the top and bottom of the center point that are included within the rectangle.
            </param>
        </member>
        <member name="P:GoRogue.Rectangle.Area">
            <summary>
            Calculates the area of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Center">
            <summary>
            The center coordinate of the rectangle, rounded up if the exact center is between two
            positions. The center of a rectangle with width/height 1 is its Position.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Height">
            <summary>
            The height of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.IsEmpty">
            <summary>
            Whether or not this rectangle is empty (has width and height of 0).
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MaxExtent">
            <summary>
            The maximum X and Y coordinates that are included in the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MaxExtentX">
            <summary>
            The maximum X-coordinate that is included in the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MaxExtentY">
            <summary>
            The maximum Y-coordinate that is included in the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MinExtent">
            <summary>
            Minimum extent of the rectangle (minimum x and y values that are included within it).
            Identical to the Position because we define the rectangle's position by its minimum extent.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MinExtentX">
            <summary>
            X-value of the minimum extent of the rectangle (minimum x value that is included within
            it). Identical to the X value because we define the rectangle's position by its minimum extent.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.MinExtentY">
            <summary>
            Y-value of the minimum extent of the rectangle (minimum y value that is included within
            it). Identical to the Y value because we define the rectangle's position by its minimum extent.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Perimeter">
            <summary>
            Calculates the perimeter length of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Position">
            <summary>
            Coord representing the position (min x- and y-values) of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Size">
            <summary>
            Returns a coordinate (Width, Height), which represents the size of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Width">
            <summary>
            The width of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.X">
            <summary>
            X-coordinate of position of the rectangle.
            </summary>
        </member>
        <member name="P:GoRogue.Rectangle.Y">
            <summary>
            Y-coordinate of position of the rectangle.
            </summary>
        </member>
        <member name="M:GoRogue.Rectangle.CreateWithExtents(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle with the given minimum and maximum extents. Effectively a
            constructor, but with extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="minX">Minimum x coordinate that is inside the rectangle.</param>
            <param name="minY">Minimum y coordinate that is inside the rectangle.</param>
            <param name="maxX">Maximum x coordinate that is inside the rectangle.</param>
            <param name="maxY">Maximum y coordinate that is inside the rectangle.</param>
            <returns>A new Rectangle with the given minimum and maximum extents.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.CreateWithExtents(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Creates a rectangle with the given minimum and maximum extents. Effectively a
            constructor, but with extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="minExtent">Minimum (x, y) coordinates that are inside the rectangle.</param>
            <param name="maxExtent">Maximum (x, y) coordinates that are inside the rectangle.</param>
            <returns>A new Rectangle with the given minimum and maximum extents.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.CreateWithRadius(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle centered on the given position, with the given horizontal and
            vertical radius values. Effectively a constructor, but with extra overloads not possible
            to provide in constructors alone.
            </summary>
            <param name="centerX">X-value of the center of the rectangle.</param>
            <param name="centerY">Y-value of the center of the rectangle.</param>
            <param name="horizontalRadius">
            Number of units to the left and right of the center point that are included within the rectangle.
            </param>
            <param name="verticalRadius">
            Number of units to the top and bottom of the center point that are included within the rectangle.
            </param>
            <returns>A new rectangle with the given center point and radius values.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.CreateWithRadius(GoRogue.Coord,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle centered on the given position, with the given horizontal and
            vertical radius values. Effectively a constructor, but with extra overloads not possible
            to provide in constructors alone.
            </summary>
            <param name="center">Center of the rectangle.</param>
            <param name="horizontalRadius">
            Number of units to the left and right of the center point that are included within the rectangle.
            </param>
            <param name="verticalRadius">
            Number of units to the top and bottom of the center point that are included within the rectangle.
            </param>
            <returns>A new rectangle with the given center point and radius values.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.CreateWithSize(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a rectangle with the given position and size. Effectively a constructor, but with
            extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="x">Minimum x coordinate that is inside the rectangle.</param>
            <param name="y">Minimum y coordinate that is inside the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            &gt;
            <returns>A new rectangle at the given position with the given width and height.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.CreateWithSize(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Creates a rectangle with the given position and size. Effectively a constructor, but with
            extra overloads not possible to provide in constructors alone.
            </summary>
            <param name="position">Minimum (x, y) values that are inside the resulting rectangle.</param>
            <param name="size">The size of the rectangle, in form (width, height).</param>
            <returns>A new rectangle at the given position with the given size.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetDifference(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Gets a MapArea representing every cell in rect1 that is NOT in rect2.
            </summary>
            <param name="rect1">First operand.</param>
            <param name="rect2">Second operand.</param>
            <returns>A MapArea representing every cell in rect1 that is NOT in rect2.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetExactUnion(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Gets a MapArea representing the exact union of the specified rectangles.
            </summary>
            <param name="r1">First rectangle.</param>
            <param name="r2">Second rectangle.</param>
            <returns>A MapArea containing exactly those positions in one (or both) rectangles.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetIntersection(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Returns the rectangle that represents the intersection of the two rectangles specified,
            or the empty rectangle if the specified rectangles do not intersect.
            </summary>
            <param name="r1">First rectangle.</param>
            <param name="r2">Second rectangle.</param>
            <returns>
            Rectangle representing the intersection of r1 and r2, or the empty rectangle if the two
            rectangles do not intersect.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetUnion(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Gets the smallest possible rectangle that includes the entire area of both r1 and r2.
            </summary>
            <param name="r1">First rectangle.</param>
            <param name="r2">Second rectangle.</param>
            <returns>
            The smallest possible rectangle that includes the entire area of both r1 and r2.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Inequality(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            Opposite of !=.
            </summary>
            <param name="r1">First rectangle.</param>
            <param name="r2">Second rectangle.</param>
            <returns>true if the rectangles do NOT encompass the same area, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.op_Equality(GoRogue.Rectangle,GoRogue.Rectangle)">
            <summary>
            See Equals.
            </summary>
            <param name="r1">First rectangle.</param>
            <param name="r2">Second rectangle.</param>
            <returns>
            true if the area of the two rectangles encompass the exact same area, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.CenterOn(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that is the same size as the current one, but with
            the center moved to the given position.
            </summary>
            <param name="center">The center-point for the new Rectangle.</param>
            <returns>
            A new Rectangle that is the same size as the current one, but with the center moved to
            the given location.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.CenterOn(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that is the same size as the current one, but with
            the center moved to the given position.
            </summary>
            <param name="x">X-value for the center-point of the new Rectangle.</param>
            <param name="y">Y-value for the center-point of the new Rectangle.</param>
            <returns>
            A new Rectangle that is the same size as the current one, but with the center moved to
            the given location.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeHeight(System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose position is the same as the current one, but
            has its height changed by the given delta-change value.
            </summary>
            <param name="deltaHeight">Delta-change for the height of the new Rectangle.</param>
            <returns>A new Rectangle whose height is modified by the given delta-change value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeSize(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose position is the same as the current one, but
            has its width and height changed by the given delta-change values.
            </summary>
            <param name="deltaWidth">Delta-change for the width of the new rectangle.</param>
            <param name="deltaHeight">Delta-change for the height of the new rectangle.</param>
            <returns>
            A new rectangle whose width/height are modified by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeSize(GoRogue.Coord)">
            <summary>
            Creates and returns a new Rectangle whose position is the same as the current one, but
            has its width and height changed by the given delta-change values.
            </summary>
            <param name="deltaChange">
            Vector (deltaWidth, deltaHeight) specifying the delta-change values for the width/height
            of the new Rectangle.
            </param>
            <returns>
            A new rectangle whose width/height are modified by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.ChangeWidth(System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose position is the same as the current one, but
            has its width changed by the given delta-change value.
            </summary>
            <param name="deltaWidth">Delta-change for the width of the new Rectangle.</param>
            <returns>A new Rectangle whose width is modified by the given delta-change value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Contains(GoRogue.Coord)">
            <summary>
            Returns whether or not the specified point is considered within the rectangle.
            </summary>
            <param name="position">The position to check.</param>
            <returns>Whether or not the specified point is considered within the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Contains(System.Int32,System.Int32)">
            <summary>
            Returns whether or not the specified point is considered within the rectangle.
            </summary>
            <param name="x">The x-value position to check.</param>
            <param name="y">The y-value position to check.</param>
            <returns>Whether or not the specified point is considered within the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Contains(GoRogue.Rectangle)">
            <summary>
            Returns whether or not the specified rectangle is considered completely contained within
            the current one.
            </summary>
            <param name="other">The rectangle to check.</param>
            <returns>
            True if the given rectangle is completely contained within the current one, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Equals(GoRogue.Rectangle)">
            <summary>
            Compares based upon whether or not the areas contained within the rectangle are identical
            in both position and size.
            </summary>
            <param name="other">Rectangle to compare the current one to.</param>
            <returns>
            true if the area of the two rectangles encompass the exact same area, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Equals(System.Object)">
            <summary>
            Compares to arbitray object.
            </summary>
            <param name="obj">Object to compare to.</param>
            <returns>
            true if the object is a Rectangle instance and encompasses the same area, false otherwise.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Expand(System.Int32,System.Int32)">
            <summary>
            Returns a new Rectangle, expanded to include the additional specified number of tiles on
            the left/right and top/bottom.
            </summary>
            <param name="horizontalChange">
            Number of additional tiles to include on the left/right of the rectangle.
            </param>
            <param name="verticalChange">
            Number of additional tiles to include on the top/bottom of the rectangle.
            </param>
            <returns>A new Rectangle, expanded appropriately.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.GetHashCode">
            <summary>
            Simple hashing.
            </summary>
            <returns>Hash code for rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Intersects(GoRogue.Rectangle)">
            <summary>
            Returns whether or not the given rectangle intersects the current one.
            </summary>
            <param name="other">The rectangle to check.</param>
            <returns>True if the given rectangle intersects with the current one, false otherwise.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Move(GoRogue.Coord)">
            <summary>
            Creates and returns a new Rectangle that has its Position moved to the given position.
            </summary>
            <param name="position">The Position for the new rectangle.</param>
            <returns>A new rectangle that has its Position changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Move(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new Rectangle that has its Position moved to the given position.
            </summary>
            <param name="x">X-value for the position of the new Rectangle.</param>
            <param name="y">Y-value for the position of the new Rectangle.</param>
            <returns>A new rectangle with the Position changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MoveIn(GoRogue.Direction)">
            <summary>
            Creates and returns a new Rectangle that has its Position moved in the given direction.
            </summary>
            <param name="direction">The direction to move the new Rectangle in.</param>
            <returns>A new rectangle that has its position moved in the given direction.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MoveX(System.Int32)">
            <summary>
            Creates and returns a new Rectangle that has its X value moved to the given x-coordinate.
            </summary>
            <param name="x">The X value for the new Rectangle.</param>
            <returns>A new rectangle with X changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.MoveY(System.Int32)">
            <summary>
            Creates and returns a new Rectangle that has its Y value moved to the given y-coordinate.
            </summary>
            <param name="y">The Y value for the new Rectangle.</param>
            <returns>A new rectangle with Y changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Positions">
            <summary>
            Returns all positions in the rectangle, in order of for (y = 0...) for (x = 0...) nested
            for loop.
            </summary>
            <returns>All positions in the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.RandomPosition(Troschuetz.Random.IGenerator)">
            <summary>
            Returns a random position from within this rectangle.
            </summary>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>A random position from within the rectangle.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.RandomPosition(System.Func{GoRogue.Coord,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Returns a random position from within this rectangle, for which the selector function
            specified returns true Random positions will continuously be generated until one that
            qualifies is found.
            </summary>
            <param name="selector">
            Selector function that takes a Coord, and returns true if it is an acceptable selection,
            and false otherwise.
            </param>
            <param name="rng">The rng to use. Defaults to SingletonRandom.DefaultRNG.</param>
            <returns>
            A random position from within the rectangle for which the given selector function
            returned true.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetHeight(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has the same position and width as the current
            one, but with the height changed to the given value.
            </summary>
            <param name="height">The height for the new Rectangle.</param>
            <returns>A new rectangle with the Height changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMaxExtent(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the maximum extent is the specified value.
            </summary>
            <param name="maxExtent">The maximum extent of the new rectangle.</param>
            <returns>A new Rectangle that has its maximum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMaxExtent(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the maximum extent is the specified value.
            </summary>
            <param name="x">The x-value for the minimum extent of the new rectangle.</param>
            <param name="y">The y-value for the minimum extent of the new rectangle.</param>
            <returns>A new Rectangle that has its maximum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMaxExtentX(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the x-value of maximum extent is changed to the specified value.
            </summary>
            <param name="x">The x-coordinate for the maximum extent of the new rectangle.</param>
            <returns>A new rectangle, with the MaxExtentX adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMaxExtentY(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the y-value of maximum extent is changed to the specified value.
            </summary>
            <param name="y">The y-coordinate for the maximum extent of the new rectangle.</param>
            <returns>A new rectangle, with the MaxExtentY adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMinExtent(GoRogue.Coord)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the minimum extent is the specified value.
            </summary>
            <param name="minExtent">The minimum extent of the new rectangle.</param>
            <returns>A new Rectangle that has its minimum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMinExtent(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the minimum extent is the specified value.
            </summary>
            <param name="x">The x-value for the minimum extent of the new rectangle.</param>
            <param name="y">The y-value for the minimum extent of the new rectangle.</param>
            <returns>A new Rectangle that has its minimum extent adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMinExtentX(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the x-value of minimum extent is changed to the specified value.
            </summary>
            <param name="x">The x-coordinate for the minimum extent of the new rectangle.</param>
            <returns>A new rectangle, with the MinExtentX adjusted to the specified value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetMinExtentY(System.Int32)">
            <summary>
            Creates and returns a new rectangle that has been shrunk/expanded as necessary, such that
            the y-value of minimum extent is changed to the specified value.
            </summary>
            <param name="y">The y-coordinate for the minimum extent of the new rectangle.</param>
            <returns>A new rectangle, with the MinExtentY adjusted to the specified value.</returns>
            &gt;
        </member>
        <member name="M:GoRogue.Rectangle.SetSize(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose position is the same as the current one, but
            has the specified width and height.
            </summary>
            <param name="width">The width for the new rectangle.</param>
            <param name="height">The height for the new rectangle.</param>
            <returns>A new Rectangle with the given width and height.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetSize(GoRogue.Coord)">
            <summary>
            Creates and returns a new Rectangle whose position is the same as the current one, but
            has the specified width and height.
            </summary>
            <param name="size">Vector (width, height) specifying the width/height of the new rectangle.</param>
            <returns>A new Rectangle with the given width and height.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.SetWidth(System.Int32)">
            <summary>
            Creates and returns a new rectangle that is exactly the same as the current one, but with
            the width changed to the given value.
            </summary>
            <param name="width">The width for the new Rectangle.</param>
            <returns>A new rectangle with the Width changed to the given value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.ToString">
            <summary>
            Formats as (X, Y) -&gt; (MaxX, MaxY)
            </summary>
            <returns>String formatted as above.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.Translate(GoRogue.Coord)">
            <summary>
            Creates and returns a new Rectangle whose position has been moved by the given
            delta-change values.
            </summary>
            <param name="deltaChange">Delta-x and delta-y values by which to move the new Rectangle.</param>
            <returns>
            A new rectangle, whose position has been moved by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.Translate(System.Int32,System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose position has been moved by the given
            delta-change values.
            </summary>
            <param name="dx">Delta-x value by which to move the new Rectangle.</param>
            <param name="dy">Delta-y value by which to move the new Rectangle.</param>
            <returns>
            A new rectangle, whose position has been moved by the given delta-change values.
            </returns>
        </member>
        <member name="M:GoRogue.Rectangle.TranslateX(System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose x-position has been moved by the given delta value.
            </summary>
            <param name="dx">Value by which to move the new Rectangle's x-position.</param>
            <returns>A new rectangle, whose x-position has been moved by the given delta-x value.</returns>
        </member>
        <member name="M:GoRogue.Rectangle.TranslateY(System.Int32)">
            <summary>
            Creates and returns a new Rectangle whose y-position has been moved by the given delta value.
            </summary>
            <param name="dy">Value by which to move the new Rectangle's y-position.</param>
            <returns>A new rectangle, whose y-position has been moved by the given delta-y value.</returns>
        </member>
        <member name="T:GoRogue.SenseMapping.IReadOnlySenseMap">
            <summary>
            Read-only interface of a SenseMap.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.CurrentSenseMap">
            <summary>
            IEnumerable of only positions currently "in" the sense map, eg. all positions that have a
            value other than 0.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.NewlyInSenseMap">
            <summary>
            IEnumerable of positions that DO have a non-zero value in the sense map as of the most
            current Calculate call, but DID NOT have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.NewlyOutOfSenseMap">
            <summary>
            IEnumerable of positions that DO NOT have a non-zero value in the sense map as of the
            most current Calculate call, but DID have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.IReadOnlySenseMap.SenseSources">
            <summary>
            Read-only list of all sources currently taken into account. Some may have their enabled
            flag set to false, so all of these may or may not be counted when Calculate is called.
            </summary>
        </member>
        <member name="T:GoRogue.SenseMapping.SenseMap">
            <summary>
            Class responsible for calculating a map for senses (sound, light, etc). Anything that has a
            resistance map, where 1.0 is completely impenetrable, and 0.0 is no resistance at all, can
            use this system. Typically used for FOV, however can also be used for sound maps, etc.
            Supports a few different types of spreading mechanics, including every one in the SourceType
            enum. Included in these is FOV/FOV-style shadowcasting. This will be much faster than ripple
            variations. Once one calls Calculate, one can use Coords, or x and y values, to access this
            class like an array. The double one gets back will be the "sensory value". This is a number
            between 1.0 and 0.0, where 1.0 is maximum intensity (max brightness in the case of the
            sources being light, for example), and 0.0 is no intensity at all.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.#ctor(GoRogue.MapViews.IMapView{System.Double})">
            <summary>
            Constructor. Takes the resistance map to use for calculations.
            </summary>
            <param name="resMap">The resistance map to use for calculations.</param>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.CurrentSenseMap">
            <summary>
            IEnumerable of only positions currently "in" the SenseMap, eg. all positions that have a
            value other than 0.0.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Height">
            <summary>
            Height of sense map.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.NewlyInSenseMap">
            <summary>
            IEnumerable of positions that DO have a non-zero value in the sense map as of the most
            current Calculate call, but DID NOT have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.NewlyOutOfSenseMap">
            <summary>
            IEnumerable of positions that DO NOT have a non-zero value in the sense map as of the
            most current Calculate call, but DID have a non-zero value after the previous time
            Calculate was called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.SenseSources">
            <summary>
            Read-only list of all sources currently taken into account. Some may have their enabled
            flag set to false, so all of these may or may not be counted when Calculate is called.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Width">
            <summary>
            Width of sense map.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Item(GoRogue.Coord)">
            <summary>
            Array-style indexer that takes a Coord as the index. Because of this function, given a
            SenseMap called mySenseMap, you may call mySenseMap[Coord.Get(1, 3)] to access the
            "sensory value" at (1, 3).
            </summary>
            <param name="pos">Position to get the sensory value for.</param>
            <returns>The "sensory value" at the given location.</returns>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseMap.Item(System.Int32,System.Int32)">
            <summary>
            Array-style indexer that takes an (x, y) value as the index. Similarly to the Coord
            indexer, you may call mySenseMap[1, 3] to get the "sensory value" at 1, 3.
            </summary>
            <param name="x">X-coordinate to retrieve the sensory value for.</param>
            <param name="y">Y-Coordinate to retrieve the sensory value for.</param>
            <returns>The sensory value at (x, y)</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.AddSenseSource(GoRogue.SenseMapping.SenseSource)">
            <summary>
            Adds the given SenseSource to the list of sources. If the source has its
            SenseSource.Enabled flag set when Calculate is next called, then this will be used as a source.
            </summary>
            <param name="senseSource">The "source" to add.</param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.AsReadOnly">
            <summary>
            Returns a read-only representation of the SenseMap.
            </summary>
            <returns>This SenseMap object as IReadOnlySenseMap.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.Calculate">
            <summary>
            Function to make it do things. For each enabled source in the source list, it calculates
            the sense map, and puts them all together when this function is called. Sensory values
            are capped at 1.0 automatically.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.GetEnumerator">
            <summary>
            Enumerator, in case you want to use this as a list of doubles.
            </summary>
            <returns>Enumerable of doubles (the sensory values).</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ToString(System.Char,System.Char,System.Char)">
            <summary>
            ToString that customizes the characters used to represent the map.
            </summary>
            <param name="normal">The character used for any location not in the SenseMap.</param>
            <param name="center">
            The character used for any location that is the center-point of a source.
            </param>
            <param name="sourceValue">
            The character used for any location that is in range of a SenseSource, but not a center point.
            </param>
            <returns>The string representation of the SenseMap, using the specified characters.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ToString">
            <summary>
            Returns a string representation of the map, where any location not in the SenseMap is
            represented by a '-' character, any position that is the center of some source is
            represented by a 'C' character, and any position that has a non-zero value but is not a
            center is represented by an 'S'.
            </summary>
            <returns>A (multi-line) string representation of the SenseMap.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.ToString(System.Int32)">
            <summary>
            Returns a string representation of the map, with the actual values in the senseMap,
            rounded to the given number of decimal places.
            </summary>
            <param name="decimalPlaces">The number of decimal places to round to.</param>
            <returns>
            A string representation of the map, rounded to the given number of decimal places.
            </returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Generic enumerator.
            </summary>
            <returns>Enumerator for looping.</returns>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseMap.RemoveSenseSource(GoRogue.SenseMapping.SenseSource)">
            <summary>
            Removes the given source from the list of sources. This would typically be used when the
            source is destroyed, expired, or otherwise removed from the map. For temporary disabling,
            it is better to use the SenseSource.Enabled flag.
            </summary>
            <param name="senseSource">The SenseSource to remove.</param>
        </member>
        <member name="T:GoRogue.SenseMapping.SourceType">
            <summary>
            Different types of algorithms that model how values spread from the source.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE">
            <summary>
            Performs calculation by pushing values out from the source location. Source values spread
            around corners a bit.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE_LOOSE">
            <summary>
            Similar to RIPPLE but with different spread mechanics. Values spread around edges like
            smoke or water, but maintains a tendency to curl towards the start position as it goes
            around edges.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE_TIGHT">
            <summary>
            Similar to RIPPLE, but values spread around corners only very slightly.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.RIPPLE_VERY_LOOSE">
            <summary>
            Similar to RIPPLE, but values spread around corners a lot.
            </summary>
        </member>
        <member name="F:GoRogue.SenseMapping.SourceType.SHADOW">
            <summary>
            Uses a Shadowcasting algorithm. All partially resistant grid locations are treated as
            being fully transparent (it's on-off blocking, where 1.0 in the resistance map blocks,
            and all lower values don't). Returns percentage from 1.0 at center of source to 0.0
            outside of range of source.
            </summary>
        </member>
        <member name="T:GoRogue.SenseMapping.SenseSource">
            <summary>
            Represents a source location to be used in a SenseMap. One would typically create these and
            call SenseMap.AddSenseSource with them, and perhaps retain a reference for the sake of moving
            it around or toggling it on-off. The player might have one of these that follows it around if
            SenseMap is being used as a lighting map, for instance. Note that changing values such as
            Position and Radius after the source is created is possible, however changes will not be
            reflected in any SenseSources using this source until their next Calculate call.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,GoRogue.Coord,System.Double,GoRogue.Distance)">
            <summary>
            Constructor. Takes all initial parameters, and allocates the necessary underlying arrays
            used for calculations.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,GoRogue.Coord,System.Double,GoRogue.Distance,System.Double,System.Double)">
            <summary>
            Constructor.  Creates a source whose spread is restricted to a certain angle and span.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="position">The position on a map that the source is located at.</param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
            <param name="angle">The angle in degrees that specifies the outermost center point of the cone formed
            by the source's values. 0 degrees points right.</param>
            <param name="span">
            The angle, in degrees, that specifies the full arc contained in the cone formed by the source's values --
            angle/2 degrees are included on either side of the cone's center line.
            </param>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.#ctor(GoRogue.SenseMapping.SourceType,System.Int32,System.Int32,System.Double,GoRogue.Distance)">
            <summary>
            Constructor. Takes all initial parameters, and allocates the necessary underlying arrays
            used for calculations.
            </summary>
            <param name="type">The spread mechanics to use for source values.</param>
            <param name="positionX">
            The X-value of the position on a map that the source is located at.
            </param>
            <param name="positionY">
            The Y-value of the position on a map that the source is located at.
            </param>
            <param name="radius">
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed.
            </param>
            <param name="distanceCalc">
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius).
            </param>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.DistanceCalc">
            <summary>
            The distance calculation used to determine what shape the radius has (or a type
            implicitly convertible to Distance, eg. Radius)
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Enabled">
            <summary>
            Whether or not this source is enabled. If a source is disabled when its SenseMap's
            Calculate function is called, the source does not calculate values and is effectively
            assumed to be "off".
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Position">
            <summary>
            The position on a map that the source is located at.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.IsAngleRestricted">
            <summary>
            Whether or not the spreading of values from this source is restricted to an angle and span.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Angle">
            <summary>
            If IsAngleRestricted is true, the angle in degrees that represents a line from the source's start to
            the outermost center point of the cone formed by the source's calculated values.  0 degrees points right.
            If IsAngleRestricted is false, this will be 0.0 degrees.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Span">
            <summary>
            If IsAngleRestricted is true, the angle in degrees that represents the full arc of the cone formed by
            the source's calculated values.  If IsAngleRestricted is false, it will be 360 degrees.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Radius">
            <summary>
            The maximum radius of the source -- this is the maximum distance the source values will
            emanate, provided the area is completely unobstructed. Changing this will trigger
            resizing (re-allocation) of the underlying arrays. However, data is not copied over --
            there is no need to since Calculate in SenseMap immediately copies values from local
            array to its "master" array.
            </summary>
        </member>
        <member name="P:GoRogue.SenseMapping.SenseSource.Type">
            <summary>
            The spread mechanics to use for source values.
            </summary>
        </member>
        <member name="M:GoRogue.SenseMapping.SenseSource.ToString">
            <summary>
            Returns a string representation of the configuration of this SenseSource.
            </summary>
            <returns>A string representation of the configuration of this SenseSource.</returns>
        </member>
        <member name="T:GoRogue.SpatialMap`1">
            <summary>
            Designed as an more efficient data structure for recording objects on a map. The simple
            version: if you're about to use a List to store a bunch of objects in your map, consider
            using this or MultiSpatialMap instead!
            </summary>
            <remarks>Typical roguelikes will use a 2D
            array (or 1D array accessed as a 2D array), for terrain, and lists of objects for things like
            entities, items, etc. This is simple but ultimately not efficient; for example, in that
            implementation, determining if there is an object at a location takes an amount of time
            proportional to the number of objects in this list. However, the other simple option is to
            use an array with size equal to the size of the map (as many do for terrain) for all object
            lists. This is even less ideal, as in that case, the time to iterate over all objects becomes
            proportional to the size of the map (since one has to do that for rendering, ouch!), which is
            typically much larger than the number of objects in a list. This is the problem SpatialMap is
            designed to solve. It provides fast, near-constant-time operations for getting the object at
            a location, adding entities, removing entities, and will allow you to iterate through all
            objects in the SpatialMap in time proportional to the number of objects in it (the best
            possible). Effectively, it is a more efficient list for objects that have a position
            associated with them. This implementation can only allow one item at a given location at a
            time -- for an implementation that allows multiple items, see MultiSpatialMap. The
            objects stored in a SpatialMap must implement the IHasID (see that interface's documentation
            for an easy implementation example). This is used internally to keep track of the objects,
            since uints are easily (efficiently) hashable.
            </remarks>
            <typeparam name="T">The type of object that will be contained by this SpatialMap.  Must implement IHasID and be a reference-type.</typeparam>
        </member>
        <member name="M:GoRogue.SpatialMap`1.#ctor(System.Int32)">
            <summary>
            Constructor. Creates an empty SpatialMap.
            </summary>
            <param name="initialCapacity">
            The initial maximum number of elements the SpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="T:GoRogue.AdvancedSpatialMap`1">
            <summary>
            Advanced version of SpatialMap that allows for use of a custom IEqualityComparer for hashing and comparison of type T.
            May be useful for cases where one does not want to implement IHasID, or if you need to use a value type in a SpatialMap.  For simple
            cases, it is recommended to use SpatialMap instead.
            </summary>
            <remarks>
            Be mindful of the efficiency of your hashing function specified in the IEqualityComparer -- it will in large part determine the performance of
            AdvancedSpatialMap!
            </remarks>
            <typeparam name="T">The type of object that will be contained by this AdvancedSpatialMap.</typeparam>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            Constructor. Creates an empty AdvancedSpatialMap.
            </summary>
            <param name="comparer">Equality comparer to use for comparison and hashing of type T.  Be mindful of the efficiency
            of this instances GetHashCode function, as it will determine the efficiency of many AdvancedSpatialMap functions.</param>
            <param name="initialCapacity">
            The initial maximum number of elements the SpatialMap can hold before it has to
            internally resize data structures. Defaults to 32.
            </param>
        </member>
        <member name="E:GoRogue.AdvancedSpatialMap`1.ItemAdded">
            <summary>
            See ISpatialMap.ItemAdded.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedSpatialMap`1.ItemMoved">
            <summary>
            See ISpatialMap.ItemMoved.
            </summary>
        </member>
        <member name="E:GoRogue.AdvancedSpatialMap`1.ItemRemoved">
            <summary>
            See ISpatialMap.ItemRemoved.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedSpatialMap`1.Count">
            <summary>
            See IReadOnlySpatialMap.Count.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedSpatialMap`1.Items">
            <summary>
            See IReadOnlySpatialMap.Items.
            </summary>
        </member>
        <member name="P:GoRogue.AdvancedSpatialMap`1.Positions">
            <summary>
            See IReadOnlySpatialMap.Positions.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Add(`0,GoRogue.Coord)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            SpatialMap and the position is not already filled. If either of those are the case,
            returns false. Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="position">The position at which to add the new item.</param>
            <returns>True if the item was added, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Add(`0,System.Int32,System.Int32)">
            <summary>
            Adds the given item at the given position, provided the item is not already in the
            SpatialMap and the position is not already filled. If either of those are the case,
            returns false. Otherwise (if item was successfully added), returns true.
            </summary>
            <param name="newItem">The item to add.</param>
            <param name="x">X-value of the position to add item to.</param>
            <param name="y">Y-value of the position to add item to.</param>
            <returns>True if the item was added, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.AsReadOnly">
            <summary>
            See IReadOnlySpatialMap.AsReadOnly.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Clear">
            <summary>
            See ISpatialMap.Clear.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Contains(`0)">
            <summary>
            See IReadOnlySpatialMap.Contains.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Contains(GoRogue.Coord)">
            <summary>
            See IReadOnlySpatialMap.Contains.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Contains(System.Int32,System.Int32)">
            <summary>
            See IReadOnlySpatialMap.Contains.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetEnumerator">
            <summary>
            Used by foreach loop, so that the class will give ISpatialTuple objects when used in a
            foreach loop. Generally should never be called explicitly.
            </summary>
            <returns>An enumerator for the SpatialMap</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Generic iterator used internally by foreach loops.
            </summary>
            <returns>Enumerator to ISpatialTuple instances.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItem(GoRogue.Coord)">
            <summary>
            Gets the item at the given position, or null/equivalent if no item exists.
            </summary>
            <remarks>
            Intended to be a more convenient function as compared to GetItems, for times when you are
            dealing exclusively with SpatialMap instances.
            </remarks>
            <param name="position">The postiion to return the item for.</param>
            <returns>
            The item at the given position, or null/equivalent if no item exists at that location.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItem(System.Int32,System.Int32)">
            <summary>
            Gets the item at the given position, or null/equivalent if no item exists.
            </summary>
            <remarks>
            Intended to be a more convenient function as compared to GetItems, for times when you are
            dealing exclusively with SpatialMap instances.
            </remarks>
            <param name="x">The x-value of the position to return the item for.</param>
            <param name="y">The y-value of the position to return the item for.</param>
            <returns>
            The item at the given position, or null/equivalent if no item exists at that location.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItems(GoRogue.Coord)">
            <summary>
            Gets the item at the given position as a 1-element enumerable if there is any item there,
            or nothing if there is nothing at that position.
            </summary>
            <remarks>
            Again, since this implementation guarantees that only one item can be at any given
            location at once, the return value is guaranteed to be at most one element. For times
            when you are know you are dealing exclusively with SpatialMap instances, this specific
            class also provides a GetItem function that returns a more intuitive null if no item was
            found, or the item at the location as applicable.
            </remarks>
            <param name="position">The position to return the item for.</param>
            <returns>
            The item at the given position as a 1-element enumerable, if there is an item there, or
            nothing if there is no item there.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetItems(System.Int32,System.Int32)">
            <summary>
            Gets the item at the given position as a 1-element enumerable if there is any item there,
            or nothing if there is nothing at that position.
            </summary>
            <remarks>
            Again, since this implementation guarantees that only one item can be at any given
            location at once, the return value is guaranteed to be at most one element. For times
            when you are know you are dealing exclusively with SpatialMap instances, this specific
            class also provides a GetItem function that returns a more intuitive null if no item was
            found, or the item at the location as applicable.
            </remarks>
            <param name="x">The x-value of the position to return the item(s) for.</param>
            <param name="y">The y-value of the position to return the item(s) for.</param>
            <returns>
            The item at the given position as a 1-element enumerable, if there is an item there, or
            nothing if there is no item there.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.GetPosition(`0)">
            <summary>
            See IReadOnlySpatialMap.GetPosition.
            </summary>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(`0,GoRogue.Coord)">
            <summary>
            Move the item specified to the position specified. Returns true if successful. If the
            item does not exist in the SpatialMap, or the position is already filled by something,
            does nothing and returns false. Otherwise, returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="target">The position to move it to.</param>
            <returns>True if the item was moved, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(`0,System.Int32,System.Int32)">
            <summary>
            Move the item specified to the position specified. Returns true if successful. If the
            item does not exist in the SpatialMap, or the position is already filled by something,
            does nothing and returns false. Otherwise, returns true.
            </summary>
            <param name="item">The item to move.</param>
            <param name="targetX">X-value of the location to move item to.</param>
            <param name="targetY">Y-value of the location to move item to.</param>
            <returns>True if the item was moved, false if not.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(GoRogue.Coord,GoRogue.Coord)">
            <summary>
            Moves whatever is at position current, if anything, to postion target. If something was
            moved, returns what was moved. If nothing was moved, eg. either there was nothing at
            position current or already something at position target, returns nothing.
            </summary>
            <remarks>
            Since this implementation of ISpatialMap guarantees that only one item may be at any
            given location at a time, the returned values will either be none, or a single value.
            </remarks>
            <param name="current">The position of the item to move.</param>
            <param name="target">The position to move the item to.</param>
            <returns>
            The item moved as a 1-element IEnumerable if something was moved, or nothing if no item
            was moved.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Move(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Moves whatever is at position current, if anything, to postion target. If something was
            moved, returns what was moved. If nothing was moved, eg. either there was nothing at
            position current or already something at position target, returns nothing.
            </summary>
            <remarks>
            Since this implementation of ISpatialMap guarantees that only one item may be at any
            given location at a time, the returned values will either be none, or a single value.
            </remarks>
            <param name="currentX">X-value of the location to move item from.</param>
            <param name="currentY">Y-value of the location to move item from.</param>
            <param name="targetX">X-value of the location to move item to.</param>
            <param name="targetY">Y-value of the location to move item to.</param>
            <returns>
            The item moved as a 1-element IEnumerable if something was moved, or nothing if no item
            was moved.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Remove(`0)">
            <summary>
            Removes the item specified, if it exists, and returns true. Returns false if the item was
            not in the SpatialMap.
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if the item was removed, false if the item was not found.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Remove(GoRogue.Coord)">
            <summary>
            Removes whatever is at the given position, if anything, and returns the item removed as a
            1-element IEnumerable. Returns nothing if no item was at the position specified.
            </summary>
            <remarks>
            Again, since this implementation guarantees that only one item can be at any given
            location at a time, the returned value is guaranteed to be either nothing or a single element.
            </remarks>
            <param name="position">The position of the item to remove.</param>
            <returns>
            The item removed as a 1-element IEnumerable, if something was removed; nothing if no item
            was found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes whatever is at the given position, if anything, and returns the item removed as a
            1-element IEnumerable. Returns nothing if no item was at the position specified.
            </summary>
            <remarks>
            Again, since this implementation guarantees that only one item can be at any given
            location at a time, the returned value is guaranteed to be either nothing or a single element.
            </remarks>
            <param name="x">X-value of the position to remove item from.</param>
            <param name="y">Y-value of the position to remove item from.</param>
            <returns>
            The item removed as a 1-element IEnumerable, if something was removed; nothing if no item
            was found at that position.
            </returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.ToString">
            <summary>
            Returns a string representation of the SpatialMap.
            </summary>
            <returns>A string representation of the SpatialMap.</returns>
        </member>
        <member name="M:GoRogue.AdvancedSpatialMap`1.ToString(System.Func{`0,System.String})">
            <summary>
            Returns a string representation of the SpatialMap, allowing display of the SpatialMap's
            items in a specified way.
            </summary>
            <param name="itemStringifier">Function that turns an item into a string.</param>
            <returns>A string representation of the SpatialMap.</returns>
        </member>
        <member name="T:GoRogue.Utility">
            <summary>
            Static class full of miscellaneous helper methods.
            </summary>
        </member>
        <member name="M:GoRogue.Utility.AsReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Adds an AsReadOnly method to IDictionary, similar to the AsReadOnly method of IList, that
            returns a read-only reference to the dictionary.
            </summary>
            <typeparam name="K">Type of keys of the dictionary.</typeparam>
            <typeparam name="V">Type of values of the dictionary.</typeparam>
            <param name="dictionary">
            Dictionary to create a read-only reference to -- never specified manually as this is an
            extension method.
            </param>
            <returns>A ReadOnlyDictionary instance for the specified dictionary.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.String,System.String)">
            <summary>
            Extension method for generic IEnumerable/List collection allowing printing the contents.
            Takes the characters to surround the list in, the method to use to get the string
            representation of each element (defaulting to the ToString function of type T), and the
            characters to use to separate the list elements.
            </summary>
            <remarks>Defaults to a representation looking something like [elem1, elem2, elem3].</remarks>
            <typeparam name="T">Type of elements in the IEnumerable.</typeparam>
            <param name="enumerable">
            IEnumerable to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="begin">Character(s) that should precede the list elements.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each element. Null uses the ToString
            function of type T.
            </param>
            <param name="separator">Characters to separate the list by.</param>
            <param name="end">Character(s) that should follow the list elements.</param>
            <returns>A string representation of the IEnumerable.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(System.Collections.Generic.ISet{``0},System.String,System.Func{``0,System.String},System.String,System.String)">
            <summary>
            Extension method for sets allowing printing the contents. Takes the characters to
            surround the set elements in, the method to use to get the string representation of each
            element (defaulting to the ToString function of type T), and the characters to use to
            separate the set elements.
            </summary>
            <remarks>Defaults to a representation looking something like set(elem1, elem2, elem3).</remarks>
            <typeparam name="T">Type of elements in the IEnumerable.</typeparam>
            <param name="set">
            Set to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="begin">Character(s) that should precede the set elements.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each element. Null uses the ToString
            function of type T.
            </param>
            <param name="separator">Characters to separate the list by.</param>
            <param name="end">Character(s) that should follow the list elements.</param>
            <returns>A string representation of the ISet.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``2(System.Collections.Generic.IDictionary{``0,``1},System.String,System.Func{``0,System.String},System.Func{``1,System.String},System.String,System.String,System.String)">
            <summary>
            Extension method for dictionaries allowing printing the contents. Takes the characters to
            surround the dictionary elements in, the method to use to get the string representation
            of each key and value (defaulting to the ToString function of the types), and the
            characters to use to separate the value from keys, and the key-value pairs.
            </summary>
            <remarks>
            Defaults to a representation looking something like {key : value, key : value}.
            </remarks>
            <typeparam name="K">Type of keys of the dictionary.</typeparam>
            <typeparam name="V">Type of values of the dictionary.</typeparam>
            <param name="dictionary">
            Dictionary to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="begin">Character(s) that should precede the dictionary elements.</param>
            <param name="keyStringifier">
            Function to use to get the string representation of each key. Null uses the ToString
            function of type K.
            </param>
            <param name="valueStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type V.
            </param>
            <param name="kvSeparator">Characters to separate each value from its key.</param>
            <param name="pairSeparator">Characters to separate each key-value pair from the next.</param>
            <param name="end">Character(s) that should follow the dictionary elements.</param>
            <returns>A string representation of the IDictionary.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToString``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays allowing printing the contents. Takes characters to
            surround the array, and each row, the method used to get the string representation of
            each element (defaulting to the ToString function of type T), and separation characters
            for each element and row.
            </summary>
            <typeparam name="T">Type of elements in the 2D array.</typeparam>
            <param name="array">
            The array to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="begin">Character(s) that should precede the array.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the array.</param>
            <returns>A string representation of the 2D array.</returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToStringGrid``1(``0[0:,0:],System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays allowing printing the contents, as if the array represents
            a grid-map. This differs from ExtendToString in that this method prints the grid where
            array[x+1, y] is printed to the RIGHT of array[x, y], rather than BELOW it. Effectively
            it assumes the indexes being used are grid/coordinate plane coordinates. Takes characters
            to surround the array, and each row, the method used to get the string representation of
            each element (defaulting to the ToString function of type T), and separation characters
            for each element and row.
            </summary>
            <typeparam name="T">Type of elements in the 2D array.</typeparam>
            <param name="array">
            The array to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="begin">Character(s) that should precede the array.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the array.</param>
            <returns>
            A string representation of the 2D array, as if the array is a 2D grid-based map.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.ExtendToStringGrid``1(``0[0:,0:],System.Int32,System.String,System.String,System.Func{``0,System.String},System.String,System.String,System.String,System.String)">
            <summary>
            Extension method for 2D arrays allowing printing the contents, as if the array represents
            a grid-map. This differs from ExtendToString in that this method prints the grid where
            array[x+1, y] is printed to the RIGHT of array[x, y], rather than BELOW it. Effectively
            it assumes the indexes being used are grid/coordinate plane coordinates. Takes the size
            of the field to give each element, characters to surround the array, and each row, the
            method used to get the string representation of each element (defaulting to the ToString
            function of type T), and separation characters for each element and row.
            </summary>
            <typeparam name="T">Type of elements in the 2D array.</typeparam>
            <param name="array">
            The array to stringify -- never specified manually as this is an extension method.
            </param>
            <param name="fieldSize">
            The amount of space each element should take up in characters. A positive number aligns
            the text to the right of the space, while a negative number aligns the text to the left.
            </param>
            <param name="begin">Character(s) that should precede the array.</param>
            <param name="beginRow">Character(s) that should precede each row.</param>
            <param name="elementStringifier">
            Function to use to get the string representation of each value. Null uses the ToString
            function of type T.
            </param>
            <param name="rowSeparator">Character(s) to separate each row from the next.</param>
            <param name="elementSeparator">Character(s) to separate each element from the next.</param>
            <param name="endRow">Character(s) that should follow each row.</param>
            <param name="end">Character(s) that should follow the array.</param>
            <returns>
            A string representation of the 2D array, as if the array is a 2D grid-based map.
            </returns>
        </member>
        <member name="M:GoRogue.Utility.FisherYatesShuffle``1(System.Collections.Generic.List{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method for List that implements a fisher-yates shuffle. Modifies the list it is
            called on to randomly rearrange the elements therein.
            </summary>
            <remarks>
            Since this is an extension method, if we have a List&lt;T&gt; myList, we can simply call
            myList.FisherYatesShuffle(rng). However, do note that for the method to be detected
            properly, the namespace GoRogue (the namespace the Utility class is in) must be in a
            using statement.
            </remarks>
            <typeparam name="T">Type of elements in the list.</typeparam>
            <param name="list">
            List being operated on -- never specified manually as this is an extension method.
            </param>
            <param name="rng">RNG to use.</param>
        </member>
        <member name="M:GoRogue.Utility.Multiply(System.String,System.Int32)">
            <summary>
            "Multiplies", aka repeats, a given string the given number of times.
            </summary>
            <param name="str">
            String to repeat. Never specified manually since this is an extension method.
            </param>
            <param name="numTimes">The number of times to repeat the string.</param>
            <returns>The string str repeated numTimes times.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomIndex``1(System.Collections.Generic.IReadOnlyList{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random valid index from the list, using the
            rng specified.
            -1 is returned if the list is empty.
            </summary>
            <typeparam name="T">Type of elements in the list.</typeparam>
            <param name="list">
            List being operated on -- never specified manually as this is an extension method.
            </param>
            <param name="rng">RNG to use.</param>
            <returns>Index selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomIndex``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{System.Int32,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random valid index from the list for which
            the selector function given returns true, using the rng specified. Indices are repeatedly
            selected until a qualifying index is found.
            -1 is returned if the list is empty.
            </summary>
            <typeparam name="T">Type of elements in the list.</typeparam>
            &gt;
            <param name="list">
            List being operated on -- never specified manually as this is an extension method.
            </param>
            <param name="selector">
            Function that returns true if the given index is valid selection, false otherwise.
            </param>
            <param name="rng">RNG to use.</param>
            <returns>Index selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomItem``1(System.Collections.Generic.IReadOnlyList{``0},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random item from the list, using the rng
            specified. Default for type T is returned if the list is empty.
            </summary>
            <typeparam name="T">Type of elements in the list.</typeparam>
            <param name="list">
            List being operated on -- never specified manually as this is an extension method.
            </param>
            <param name="rng">RNG to use.</param>
            <returns>Item selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.RandomItem``1(System.Collections.Generic.IReadOnlyList{``0},System.Func{``0,System.Boolean},Troschuetz.Random.IGenerator)">
            <summary>
            Extension method that selects and returns a random item from the list for which the given
            selector returns true, using the rng specified. Items are repeatedly selected until a
            qualifying item is found. Default for type T is returned if the list is empty.
            </summary>
            <typeparam name="T">Type of elements in the list.</typeparam>
            <param name="list">
            List being operated on -- never specified manually as this is an extension method.
            </param>
            <param name="selector">
            Function that returns true if the given item is valid selection, false otherwise.
            </param>
            <param name="rng">RNG to use.</param>
            <returns>Item selected.</returns>
        </member>
        <member name="M:GoRogue.Utility.Swap``1(``0@,``0@)">
            <summary>
            Convenience function that swaps the values pointed to by x and y.
            </summary>
            <typeparam name="T">
            Type of values being swapped -- generally determinable implicitly by the compiler.
            </typeparam>
            <param name="lhs">Left-hand value.</param>
            <param name="rhs">Right-hand value.</param>
        </member>
        <member name="M:GoRogue.Utility.Yield``1(``0)">
            <summary>
            Convenience function that yields the given item as a single-item IEnumerable.
            </summary>
            <typeparam name="T">
            Type of the item. Generally the compiler determines this since it is an extension method.
            </typeparam>
            <param name="item">
            The item to yield. Never specified manually as this is an extension method.
            </param>
            <returns>An IEnumerable containing only the item the function is called on.</returns>
        </member>
        <member name="M:GoRogue.Utility.Yield``1(``0[])">
            <summary>
            Convenience function that takes multiple parameters and converts them to an IEnumerable.
            </summary>
            <typeparam name="T">Type of the parameters.</typeparam>
            <param name="values">Parameters (specified as multiple parameters to the function)</param>
            <returns>
            An IEnumerable of all of the given items, in the order they were given to the function.
            </returns>
        </member>
    </members>
</doc>
